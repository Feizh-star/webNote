# Vue3文档阅读笔记
## 一、基础
### 1. 响应式基础
> **无论是ref变量/属性还是reactive变量/属性，只要被直接重新赋值，就会丢失响应性连接（与之关联的视图、监听、计算都会不再更新）**
#### 1.1 reactive()
1. 不能随意更改reactive变量的指向，否则这个变量的所有响应式连接都将中断
    * 原因：reactive 变量的响应式连接在组件初始化时就已经建立了，将其指向一个新的对象（即使它也是一个经过reactive 包装的proxy）不会使响应式连接重新更新到新的proxy身上
2. 如果将reactive变量的简单类型的属性**解构**或**赋值**给其他变量，新的变量是没有响应式连接的
3. 但是reactive变量的复杂类型的属性可以进行**解构**或**赋值**，新的变量仍然具有响应性（指向同一个内存地址嘛）
#### 1.2 ref()
> 简单类型经ref处理后得到的不是一个proxy（目测还是getter/setter），对象经过ref处理后`.value`属性是一个proxy（其实就是内部调用了reactive）
1. 使用：
    * 使用ref()包装简单类型得到：`{ value: raw value }`，真正具备响应性的是`.value`属性
    * 使用ref()包装复杂类型得到：`{ value: proxy}`，proxy的target是原始对象
    * 对于一个ref对象，可以通过.value直接将其赋值为一个新的对象，不会丢失相应性（即赋值时会自动调用reactive 包装新的对象）
      ```js
      const state = ref({ count: 0 })
      state.value = { count: 1 } // state.value将是一个新的proxy，但{{state.count}}（此处有解包）的依赖依然会得到更新
2. 解包：顶层指的是“不属于对象的属性”
    * 当ref变量在模板上下文的顶层被访问时（在模板上下文的顶层：隐含了它在组合式api上下文中也自然是顶层）
        * 复杂类型的ref可以直接用“.”访问它的属性，而不需要加上.value
          ```js
          // 在模板中可以直接使用{{ state.count }}而不能用{{ state.value.count }}
          const state = ref({ count: 0 })
    * 当ref变量/属性是一个模板中的文本插值`{{}}`内的表达式的计算终值（例如逻辑运算、三元表达式等）
    * 当ref作为一个响应式对象的属性在组合式api中被访问（包括读和写）时，但是**集合类型除外**（Array，Map，Set等）
