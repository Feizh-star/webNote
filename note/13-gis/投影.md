## 一、球面墨卡托投影

墨卡托投影是一种保持角度（即共形性）的地图投影，其基本思想是把地球上的经纬网映射到平面上，同时保持小范围内的角度不变。下面介绍特别是 y 轴（南北方向）的公式如何推导出来的。

<img src="D:\workspace-hx\tjh\note\webNote\note\13-gis\projection-img\img1.jpg" style="zoom:45%;" />

![](D:\workspace-hx\tjh\note\webNote\note\13-gis\projection-img\img2.jpg)

---

### 1. 基本思路

在墨卡托投影中，为了保证局部形状（角度）保持不变，要求东西方向和南北方向的局部尺度相同。  
- 东西方向：通常直接取 $x = R \lambda$（这里 $R$ 是地球半径，$\lambda$ 是经度），尺度因子是 $R$。
- 南北方向：需要确定 $y$ 关于纬度 $\varphi$ 的关系，使得在任一点上的南北方向的尺度因子也为 $R \sec\varphi$（因为球面上在纬度 $\varphi$ 处的经线间距为 $Rλ$，而东西方向的实际距离为 $Rλ\cos\varphi$，为了补偿纬度缩小，必须乘以 $1/\cos\varphi$）。

因此，为了使局部放大比例一致（对于纬度 $\varphi$ ，经度线长度表示为 $x = R \lambda$ 意味着 $x$ 轴已经放大了 $1/\cos\varphi$ ，为了 $y$ 轴也等比例放大，纬度每变化 $d\varphi$ ，$y$ （放大后的弧度）变化 $dy$ ），我们要求  
$$
\frac{dy}{d\varphi} = \sec \varphi = \frac{1}{\cos\varphi}.
$$

---

### 2. 求解 $y(\varphi)$ 的表达式

从上式出发，计算积分：
$$
y(\varphi) = \int \sec \varphi \, d\varphi.
$$

我们知道积分公式：
$$
\int \sec \varphi \, d\varphi = \ln | \sec \varphi + \tan \varphi | + C.
$$

一般我们选择常数 $C=0$（或者通过适当平移 y 轴使得 $\varphi=0$ 时 $y=0$），因此得到：
$$
y(\varphi) = \ln |\sec \varphi + \tan \varphi|.
$$

---

### 3. 利用三角恒等变换

利用以下三角恒等式，可以将上式改写成更常见的形式：
$$
\sec \varphi + \tan \varphi = \tan\left(\frac{\pi}{4} + \frac{\varphi}{2}\right).
$$

证明这一恒等式可以从两边分别化简得到（可以使用半角公式和和角公式来验证）。

因此，$y$ 的表达式也可以写成：
$$
y(\varphi) = \ln \tan\left(\frac{\pi}{4} + \frac{\varphi}{2}\right).
$$

$\ln \tan\left(\frac{\pi}{4} + \frac{\varphi}{2}\right)$ 可以看作是将 $[-85.05112878,85.05112878]$ 的纬度范围映射到 $[-180,180]$ ，这样方便归一化（$(180 + deg°) / 360$），所以通常球面墨卡托投影的有效纬度范围是 $[-85.05112878,85.05112878]$ 。

注意，有些框架可能会将最北端作为归一化0，例如`maplibre`就对 $\ln \tan\left(\frac{\pi}{4} + \frac{\varphi}{2}\right)$ 转换为度数后进行了翻转

```ts
// 以度为单位
export function mercatorXfromLng(lng: number) {
    return (180 + lng) / 360;
}
export function mercatorYfromLat(lat: number) {
    return (180 - (180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360)))) / 360;
}
```

---

### 4. 总结

墨卡托投影中，y 轴的公式来源于对局部尺度保持一致性的要求，即要求：
$$
\frac{dy}{d\varphi} = \sec\varphi.
$$
积分后得到（放大后的纬度弧度）：
$$
y(\varphi) = \ln |\sec\varphi + \tan\varphi| = \ln \tan\left(\frac{\pi}{4} + \frac{\varphi}{2}\right),
$$
再乘以地球半径 $R$ 就是球形墨卡托投影中用于计算南北方向坐标的公式（此时 $y$ 是距离，单位m；经纬度均是弧度）：
$$
\begin{cases}
x(lng) = R * lng \\
y(lat) = R * \ln \tan\left(\frac{\pi}{4} + \frac{lat}{2}\right)
\end{cases}
$$
反函数：
$$
\begin{cases}
\text{lng} = \frac{x}{R} \\
\text{lat} = 2 \tan^{-1} \left(e^{y/R} \right) - \frac{\pi}{2}
\end{cases}
$$
这种推导保证了地图在小范围内的角度和形状保持正确，但也正因为这种尺度因子随纬度急剧变化，导致高纬度区域被极度拉伸，这也是墨卡托投影的典型特点。

### 5. 归一化

#### 5.1 从经纬度到墨卡托平面坐标

在 **球面墨卡托投影** 中，我们将地球球面上的经纬度 $(\lambda, \phi)$（lon/lat）投影到平面 $(x, y)$，其中：

$$
x = R \lambda
$$

$$
y = R \ln\left(\tan\left(\frac{\pi}{4} + \frac{\phi}{2}\right)\right)
$$

其中：

- $R$：地球半径（约 6378137 米）  
- $\lambda = lon \times \pi / 180$  
- $\phi = lat \times \pi / 180$

---

#### 5.2 限定地球范围

纬度范围 $-85.05112878° \le lat \le +85.05112878°$ 被投影到有限的 y 值范围。在以上范围的边界处，纬度投影后的最大/最小值刚好等于经度投影后的最大/最小值，即赤道半圆周长。对应的墨卡托坐标范围：

$$
y_{min} = -R \pi
$$

$$
y_{max} = +R \pi
$$

因此整个地球在墨卡托平面上的坐标范围是一个正方形：

| 方向 | 范围 |
|------|------|
| X | [-Rπ, +Rπ] |
| Y | [-Rπ, +Rπ] |

---

#### 5.3 将 y 投影值归一化到 [0, 1]

地图瓦片系统希望把整个地球“折叠”成一个 [0,1]×[0,1] 的单位方形。墨卡托投影的 y 值是从北极（$+R\pi$）到南极（$-R\pi$），而屏幕坐标通常 y 轴是 **从上到下增加**，所以我们要做两个变换：

##### (1) 平移 + 缩放到 [0, 1]

把范围 [-Rπ, +Rπ] 映射到 [0,1]：

$$
y_{norm} = \frac{y_{max} - y}{2R\pi}
$$

代入 $y = R \ln(\tan(\frac{\pi}{4} + \frac{\phi}{2}))$ 和 $y_{max} = R\pi$：

$$
y_{norm} = \frac{R\pi - R\ln(\tan(\frac{\pi}{4} + \frac{\phi}{2}))}{2R\pi}
$$

---

##### (2) 简化公式

化简掉 $R$：

$$
y_{norm} = \frac{\pi - \ln(\tan(\frac{\pi}{4} + \frac{\phi}{2}))}{2\pi}
$$

进一步整理：

$$
y_{norm} = \frac{1 - \ln(\tan(\frac{\pi}{4} + \frac{\phi}{2})) / \pi}{2}
$$

这就是常见的公式形式。

---

##### (3) 等价表达形式

在 JavaScript 中常见写法：

```js
const latRad = lat * Math.PI / 180;
const y = (1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2;
```

因为：
$$
\tan\left(\frac{\pi}{4} + \frac{\phi}{2}\right) = \frac{\sin\phi + 1}{\cos\phi} = \tan(\phi) + \sec(\phi)
$$
所以两种写法数学上等价：
$$
y_{norm} = \frac{1 - \ln(\tan(\frac{\pi}{4} + \frac{\phi}{2})) / \pi}{2}=\frac{1 - \ln(\tan(\phi) + \sec(\phi)) / \pi}{2}
$$


### 6. 应用总结

* 基于 `maplibre` 进行`threejs`坐标系转换

```ts
  /**
   * 每一帧都会被调用
   * @param gl WebGL2RenderingContext | WebGLRenderingContext
   * @param args maplibregl.CustomRenderMethodInput
   */
  render(
    gl: WebGL2RenderingContext | WebGLRenderingContext,
    args: maplibregl.CustomRenderMethodInput
  ) {
    const offsetFromCenterElevation = this.map.queryTerrainElevation(this.layerOption.origin) || 0
    const sceneOriginMercator = maplibregl.MercatorCoordinate.fromLngLat(
      this.layerOption.origin,
      offsetFromCenterElevation
    )
    const rotationX = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1, 0, 0), Math.PI / 2)

    const scale = sceneOriginMercator.meterInMercatorCoordinateUnits()

    const m = new THREE.Matrix4().fromArray(args.defaultProjectionData.mainMatrix)
    const l = new THREE.Matrix4()
      .makeTranslation(sceneOriginMercator.x, sceneOriginMercator.y, sceneOriginMercator.z)
      .scale(new THREE.Vector3(scale, -scale, scale))
      .multiply(rotationX)

    this.camera.projectionMatrix = m.multiply(l)
    this.renderer.resetState()
    this.tickEffect()
    this.map.triggerRepaint()
  }
```

* 将经纬度转换为`threejs`坐标（m）

```ts
export function calculateDistanceMercatorToMeters(
  from: maplibregl.MercatorCoordinate,
  to: maplibregl.MercatorCoordinate
) {
  const mercatorPerMeter = from.meterInMercatorCoordinateUnits()
  // mercator x: 0=west, 1=east
  const dEast = to.x - from.x
  const dEastMeter = dEast / mercatorPerMeter
  // mercator y: 0=north, 1=south
  const dNorth = from.y - to.y
  const dNorthMeter = dNorth / mercatorPerMeter
  return { dEastMeter, dNorthMeter }
}

export function lnglatToWorldInMercator(
  map: maplibregl.Map,
  center: maplibregl.LngLatLike,
  lnglat: maplibregl.LngLatLike,
  eleOffset: number
) {
  const sceneElevation = map.queryTerrainElevation(center) || 0
  const modelElevation = map.queryTerrainElevation(lnglat) || 0
  const up = modelElevation - sceneElevation + eleOffset

  const centerMercator = maplibregl.MercatorCoordinate.fromLngLat(center)
  const pointMercator = maplibregl.MercatorCoordinate.fromLngLat(lnglat)
  const { dEastMeter: east, dNorthMeter: north } = calculateDistanceMercatorToMeters(
    centerMercator,
    pointMercator
  )
  return [east, up, -north] as [number, number, number] // east => x, up => y, -north => z
}

```

* 虽然球面墨卡托投影不是线性的，但是以上两组变换（坐标系变换和坐标变换）使用了同一个缩放因子（`meterInMercatorCoordinateUnits`提供），所以`threejs`世界坐标系和坐标产生了相同程度的非线性拉伸/压缩，因此即使是距离原点很远的点，它们的世界坐标依然是准确的

