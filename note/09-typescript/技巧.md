### 一、类型错误

#### 1. 循环引用自身

```typescript

type IndeterminateStatusKeys = keyof typeof indeterminateStatus; // 红色错误：类型别名“IndeterminateStatusKeys”循环引用自身
// 这里key的类型不要再用IndeterminateStatusKeys，因为类型FilterCheckedItemList在indeterminateStatus中被使用了，改成any
type FilterCheckedItemList = (key: IndeterminateStatusKeys) => Array<Item>;

const filterCheckedItemList: FilterCheckedItemList = (key: keyof typeof indeterminateStatus) => {
  const checkList: Array<string> = indeterminateStatus[key].checkList as Array<string>;
  const allList: Array<Item> = indeterminateStatus[key].allList;
  const checkSet = new Set(checkList);
  return allList.filter((item: { key: string }) => checkSet.has(item.key));
};
const indeterminateStatus = reactive({
  // ...
  timeRange: {
    checkList: [] as string[],
    allList: timeRange,
    indeterminate: false,
    all: false,
    checkedItemList: computed(() => filterCheckedItemList("timeRange")),
  },
});
```

#### 2. reactive推导失败

```typescript
type IndeterminateStatusKeys = keyof typeof indeterminateStatus;
// 原因：由于上文出现的类型循环引用，reactive无法推导类型，这里不要用IndeterminateStatusKeys，改成any
type FilterCheckedItemList = (key: IndeterminateStatusKeys) => Array<Item>;

const filterCheckedItemList: FilterCheckedItemList = (key: keyof typeof indeterminateStatus) => {
  const checkList: Array<string> = indeterminateStatus[key].checkList as Array<string>;
  const allList: Array<Item> = indeterminateStatus[key].allList;
  const checkSet = new Set(checkList);
  return allList.filter((item: { key: string }) => checkSet.has(item.key));
};
// “indeterminateStatus”隐式具有类型 "any"，因为它不具有类型批注，且在其自身的初始化表达式中得到直接或间接引用。
const indeterminateStatus = reactive({
  // ...
  timeRange: {
    checkList: [] as string[],
    allList: timeRange,
    indeterminate: false,
    all: false,
    checkedItemList: computed(() => filterCheckedItemList("timeRange")),
  },
});
```

