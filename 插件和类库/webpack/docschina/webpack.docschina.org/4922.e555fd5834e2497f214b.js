(self.webpackChunk=self.webpackChunk||[]).push([[4922],{4922:function(e){e.exports='<p>resolver 是一个帮助寻找模块绝对路径的库。 一个模块可以作为另一个模块的依赖模块，然后被后者引用，如下：</p> <pre><code class="hljs language-js"><span class="token keyword">import</span> foo <span class="token keyword">from</span> <span class="token string">\'path/to/module\'</span><span class="token punctuation">;</span>\n<span class="token comment">// 或者</span>\n<span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'path/to/module\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p>所依赖的模块可以是来自应用程序的代码或第三方库。 resolver 帮助 webpack 从每个 <code>require</code>/<code>import</code> 语句中，找到需要引入到 bundle 中的模块代码。 当打包模块时，webpack 使用 <a href="https://github.com/webpack/enhanced-resolve">enhanced-resolve</a> 来解析文件路径。</p> <h2 id="resolving-rules-in-webpack">webpack 中的解析规则 <a href="#resolving-rules-in-webpack" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>使用 <code>enhanced-resolve</code>，webpack 能解析三种文件路径：</p> <h3 id="absolute-paths">绝对路径 <a href="#absolute-paths" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <pre><code class="hljs language-js"><span class="token keyword">import</span> <span class="token string">\'/home/me/file\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">import</span> <span class="token string">\'C:\\\\Users\\\\me\\\\file\'</span><span class="token punctuation">;</span></code></pre> <p>由于已经获得文件的绝对路径，因此不需要再做进一步解析。</p> <h3 id="relative-paths">相对路径 <a href="#relative-paths" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <pre><code class="hljs language-js"><span class="token keyword">import</span> <span class="token string">\'../src/file1\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'./file2\'</span><span class="token punctuation">;</span></code></pre> <p>在这种情况下，使用 <code>import</code> 或 <code>require</code> 的资源文件所处的目录，被认为是上下文目录。在 <code>import/require</code> 中给定的相对路径，会拼接此上下文路径，来生成模块的绝对路径。</p> <h3 id="module-paths">模块路径 <a href="#module-paths" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <pre><code class="hljs language-js"><span class="token keyword">import</span> <span class="token string">\'module\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'module/lib/file\'</span><span class="token punctuation">;</span></code></pre> <p>在 <a href="configuration/resolve/index.htm#resolvemodules"/*tpa=https://webpack.docschina.org/configuration/resolve/#resolvemodules*/><code>resolve.modules</code></a> 中指定的所有目录检索模块。 你可以通过配置别名的方式来替换初始模块路径，具体请参照 <a href="configuration/resolve/index.htm#resolvealias"/*tpa=https://webpack.docschina.org/configuration/resolve/#resolvealias*/><code>resolve.alias</code></a> 配置选项。</p> <ul> <li>如果 package 中包含 <code>package.json</code> 文件，那么在 <a href="configuration/resolve/index.htm#resolveexportsfields"/*tpa=https://webpack.docschina.org/configuration/resolve/#resolveexportsfields*/><code>resolve.exportsFields</code></a> 配置选项中指定的字段会被依次查找，<code>package.json</code> 中的第一个字段会根据 <a href="guides/package-exports/index.htm"/*tpa=https://webpack.docschina.org/guides/package-exports/*/>package 导出指南</a>确定 package 中可用的 export。</li> </ul> <p>一旦根据上述规则解析路径后，resolver 将会检查路径是指向文件还是文件夹。如果路径指向文件：</p> <ul> <li>如果文件具有扩展名，则直接将文件打包。</li> <li>否则，将使用 <a href="configuration/resolve/index.htm#resolveextensions"/*tpa=https://webpack.docschina.org/configuration/resolve/#resolveextensions*/><code>resolve.extensions</code></a> 选项作为文件扩展名来解析，此选项会告诉解析器在解析中能够接受那些扩展名（例如 <code>.js</code>，<code>.jsx</code>）。</li> </ul> <p>如果路径指向一个文件夹，则进行如下步骤寻找具有正确扩展名的文件：</p> <ul> <li>如果文件夹中包含 <code>package.json</code> 文件，则会根据 <a href="configuration/resolve/index.htm#resolve-mainfields"/*tpa=https://webpack.docschina.org/configuration/resolve/#resolve-mainfields*/><code>resolve.mainFields</code></a> 配置中的字段顺序查找，并根据 <code>package.json</code> 中的符合配置要求的第一个字段来确定文件路径。</li> <li>如果不存在 <code>package.json</code> 文件或 <a href="configuration/resolve/index.htm#resolvemainfields"/*tpa=https://webpack.docschina.org/configuration/resolve/#resolvemainfields*/><code>resolve.mainFields</code></a> 没有返回有效路径，则会根据 <a href="configuration/resolve/index.htm#resolvemainfiles"/*tpa=https://webpack.docschina.org/configuration/resolve/#resolvemainfiles*/><code>resolve.mainFiles</code></a> 配置选项中指定的文件名顺序查找，看是否能在 import/require 的目录下匹配到一个存在的文件名。</li> <li>然后使用 <a href="configuration/resolve/index.htm#resolveextensions"/*tpa=https://webpack.docschina.org/configuration/resolve/#resolveextensions*/><code>resolve.extensions</code></a> 选项，以类似的方式解析文件扩展名。</li> </ul> <p>webpack 会根据构建目标，为这些选项提供合理的<a href="configuration/resolve.htm"/*tpa=https://webpack.docschina.org/configuration/resolve*/>默认</a>配置。</p> <h2 id="resolving-loaders">解析 loader <a href="#resolving-loaders" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>loader 的解析规则也遵循特定的规范。但是 <a href="configuration/resolve/index.htm#resolveloader"/*tpa=https://webpack.docschina.org/configuration/resolve/#resolveloader*/><code>resolveLoader</code></a> 配置项可以为 loader 设置独立的解析规则。</p> <h2 id="caching">缓存 <a href="#caching" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>每次文件系统访问文件都会被缓存，以便于更快触发对同一文件的多个并行或串行请求。在 <a href="configuration/watch/index.htm#watch"/*tpa=https://webpack.docschina.org/configuration/watch/#watch*/>watch 模式</a> 下，只有修改过的文件会被从缓存中移出。如果关闭 watch 模式，则会在每次编译前清理缓存。</p> <p>欲了解更多上述配置信息，请查阅 <a href="configuration/resolve.htm"/*tpa=https://webpack.docschina.org/configuration/resolve*/>Resolve API</a>。</p> '}}]);