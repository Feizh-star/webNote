(self.webpackChunk=self.webpackChunk||[]).push([[4941],{4941:function(n){n.exports='<blockquote class="tip"> <p>本指南继续沿用 <a href="guides/getting-started.htm"/*tpa=https://webpack.docschina.org/guides/getting-started*/>起步</a> 中的示例代码。请确保你已熟悉这些指南中提供的示例以及<a href="guides/output-management/index.htm"/*tpa=https://webpack.docschina.org/guides/output-management/*/>输出管理</a>章节。</p> </blockquote> <p>代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p> <p>常用的代码分离方法有三种：</p> <ul> <li><strong>入口起点</strong>：使用 <a href="configuration/entry-context.htm"/*tpa=https://webpack.docschina.org/configuration/entry-context*/><code>entry</code></a> 配置手动地分离代码。</li> <li><strong>防止重复</strong>：使用 <a href="configuration/entry-context/index.htm#dependencies"/*tpa=https://webpack.docschina.org/configuration/entry-context/#dependencies*/>Entry dependencies</a> 或者 <a href="plugins/split-chunks-plugin.htm"/*tpa=https://webpack.docschina.org/plugins/split-chunks-plugin*/><code>SplitChunksPlugin</code></a> 去重和分离 chunk。</li> <li><strong>动态导入</strong>：通过模块的内联函数调用来分离代码。</li> </ul> <h2 id="entry-points">入口起点(entry point) <a href="#entry-points" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>这是迄今为止最简单直观的分离代码的方式。不过，这种方式手动配置较多，并有一些隐患，我们将会解决这些问题。先来看看如何从 main bundle 中分离 another module(另一个模块)：</p> <p><strong>project</strong></p> <pre><code class="hljs language-diff">webpack-demo\n|- package.json\n|- webpack.config.js\n|- /dist\n|- /src\n<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> |- index.js\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> |- another-module.js\n</span></span>|- /node_modules</code></pre> <p><strong>another-module.js</strong></p> <pre><code class="hljs language-js"><span class="token keyword">import</span> _ <span class="token keyword">from</span> <span class="token string">\'lodash\'</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'Another\'</span><span class="token punctuation">,</span> <span class="token string">\'module\'</span><span class="token punctuation">,</span> <span class="token string">\'loaded!\'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">\' \'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">const path = require(\'path\');\n</span><span class="token prefix unchanged"> </span><span class="token line">\n</span><span class="token prefix unchanged"> </span><span class="token line">module.exports = {\n</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  entry: \'src/index.js\'/*tpa=https://webpack.docschina.org/src/index.js*/,\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  mode: \'development\',\n</span><span class="token prefix inserted">+</span><span class="token line">  entry: {\n</span><span class="token prefix inserted">+</span><span class="token line">    index: \'src/index.js\'/*tpa=https://webpack.docschina.org/src/index.js*/,\n</span><span class="token prefix inserted">+</span><span class="token line">    another: \'src/another-module.js\'/*tpa=https://webpack.docschina.org/src/another-module.js*/,\n</span><span class="token prefix inserted">+</span><span class="token line">  },\n</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  output: {\n</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    filename: \'main.js\'/*tpa=https://webpack.docschina.org/main.js*/,\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    filename: \'[name].bundle.js\'/*tpa=https://webpack.docschina.org/[name].bundle.js*/,\n</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    path: path.resolve(__dirname, \'dist\'),\n</span><span class="token prefix unchanged"> </span><span class="token line">  },\n</span><span class="token prefix unchanged"> </span><span class="token line">};</span></span></code></pre> <p>这将生成如下构建结果：</p> <pre><code class="hljs language-bash"><span class="token punctuation">..</span>.\n<span class="token punctuation">[</span>webpack-cli<span class="token punctuation">]</span> Compilation finished\nasset index.bundle.js <span class="token number">553</span> KiB <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span> <span class="token punctuation">(</span>name: index<span class="token punctuation">)</span>\nasset another.bundle.js <span class="token number">553</span> KiB <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span> <span class="token punctuation">(</span>name: another<span class="token punctuation">)</span>\nruntime modules <span class="token number">2.49</span> KiB <span class="token number">12</span> modules\ncacheable modules <span class="token number">530</span> KiB\n  ./src/index.js <span class="token number">257</span> bytes <span class="token punctuation">[</span>built<span class="token punctuation">]</span> <span class="token punctuation">[</span>code generated<span class="token punctuation">]</span>\n  ./src/another-module.js <span class="token number">84</span> bytes <span class="token punctuation">[</span>built<span class="token punctuation">]</span> <span class="token punctuation">[</span>code generated<span class="token punctuation">]</span>\n  ./node_modules/lodash/lodash.js <span class="token number">530</span> KiB <span class="token punctuation">[</span>built<span class="token punctuation">]</span> <span class="token punctuation">[</span>code generated<span class="token punctuation">]</span>\nwebpack <span class="token number">5.4</span>.0 compiled successfully <span class="token keyword">in</span> <span class="token number">245</span> ms</code></pre> <p>正如前面提到的，这种方式存在一些隐患：</p> <ul> <li>如果入口 chunk 之间包含一些重复的模块，那些重复模块都会被引入到各个 bundle 中。</li> <li>这种方法不够灵活，并且不能动态地将核心应用程序逻辑中的代码拆分出来。</li> </ul> <p>以上两点中，第一点对我们的示例来说无疑是个问题，因为之前我们在 <code>./src/index.js</code> 中也引入过 <code>lodash</code>，这样就在两个 bundle 中造成重复引用。在下一章节会移除重复的模块。</p> <h2 id="prevent-duplication">防止重复(prevent duplication) <a href="#prevent-duplication" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <h3 id="entry-dependencies">入口依赖 <a href="#entry-dependencies" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p>配置 <a href="configuration/entry-context/index.htm#dependencies"/*tpa=https://webpack.docschina.org/configuration/entry-context/#dependencies*/><code>dependOn</code> option</a> 选项，这样可以在多个 chunk 之间共享模块：</p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">const path = require(\'path\');\n</span><span class="token prefix unchanged"> </span><span class="token line">\n</span><span class="token prefix unchanged"> </span><span class="token line">module.exports = {\n</span><span class="token prefix unchanged"> </span><span class="token line">  mode: \'development\',\n</span><span class="token prefix unchanged"> </span><span class="token line">  entry: {\n</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    index: \'src/index.js\'/*tpa=https://webpack.docschina.org/src/index.js*/,\n</span><span class="token prefix deleted">-</span><span class="token line">    another: \'src/another-module.js\'/*tpa=https://webpack.docschina.org/src/another-module.js*/,\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    index: {\n</span><span class="token prefix inserted">+</span><span class="token line">      import: \'src/index.js\'/*tpa=https://webpack.docschina.org/src/index.js*/,\n</span><span class="token prefix inserted">+</span><span class="token line">      dependOn: \'shared\',\n</span><span class="token prefix inserted">+</span><span class="token line">    },\n</span><span class="token prefix inserted">+</span><span class="token line">    another: {\n</span><span class="token prefix inserted">+</span><span class="token line">      import: \'src/another-module.js\'/*tpa=https://webpack.docschina.org/src/another-module.js*/,\n</span><span class="token prefix inserted">+</span><span class="token line">      dependOn: \'shared\',\n</span><span class="token prefix inserted">+</span><span class="token line">    },\n</span><span class="token prefix inserted">+</span><span class="token line">    shared: \'lodash\',\n</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  },\n</span><span class="token prefix unchanged"> </span><span class="token line">  output: {\n</span><span class="token prefix unchanged"> </span><span class="token line">    filename: \'[name].bundle.js\'/*tpa=https://webpack.docschina.org/[name].bundle.js*/,\n</span><span class="token prefix unchanged"> </span><span class="token line">    path: path.resolve(__dirname, \'dist\'),\n</span><span class="token prefix unchanged"> </span><span class="token line">  },\n</span><span class="token prefix unchanged"> </span><span class="token line">};</span></span></code></pre> <p>如果我们要在一个 HTML 页面上使用多个入口时，还需设置 <code>optimization.runtimeChunk: \'single\'</code>，否则还会遇到<a href="https://bundlers.tooling.report/code-splitting/multi-entry/">这里</a>所述的麻烦。</p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">const path = require(\'path\');\n</span><span class="token prefix unchanged"> </span><span class="token line">\n</span><span class="token prefix unchanged"> </span><span class="token line">module.exports = {\n</span><span class="token prefix unchanged"> </span><span class="token line">  mode: \'development\',\n</span><span class="token prefix unchanged"> </span><span class="token line">  entry: {\n</span><span class="token prefix unchanged"> </span><span class="token line">    index: {\n</span><span class="token prefix unchanged"> </span><span class="token line">      import: \'src/index.js\'/*tpa=https://webpack.docschina.org/src/index.js*/,\n</span><span class="token prefix unchanged"> </span><span class="token line">      dependOn: \'shared\',\n</span><span class="token prefix unchanged"> </span><span class="token line">    },\n</span><span class="token prefix unchanged"> </span><span class="token line">    another: {\n</span><span class="token prefix unchanged"> </span><span class="token line">      import: \'src/another-module.js\'/*tpa=https://webpack.docschina.org/src/another-module.js*/,\n</span><span class="token prefix unchanged"> </span><span class="token line">      dependOn: \'shared\',\n</span><span class="token prefix unchanged"> </span><span class="token line">    },\n</span><span class="token prefix unchanged"> </span><span class="token line">    shared: \'lodash\',\n</span><span class="token prefix unchanged"> </span><span class="token line">  },\n</span><span class="token prefix unchanged"> </span><span class="token line">  output: {\n</span><span class="token prefix unchanged"> </span><span class="token line">    filename: \'[name].bundle.js\'/*tpa=https://webpack.docschina.org/[name].bundle.js*/,\n</span><span class="token prefix unchanged"> </span><span class="token line">    path: path.resolve(__dirname, \'dist\'),\n</span><span class="token prefix unchanged"> </span><span class="token line">  },\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  optimization: {\n</span><span class="token prefix inserted">+</span><span class="token line">    runtimeChunk: \'single\',\n</span><span class="token prefix inserted">+</span><span class="token line">  },\n</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">};</span></span></code></pre> <p>构建结果如下：</p> <pre><code class="hljs language-bash"><span class="token punctuation">..</span>.\n<span class="token punctuation">[</span>webpack-cli<span class="token punctuation">]</span> Compilation finished\nasset shared.bundle.js <span class="token number">549</span> KiB <span class="token punctuation">[</span>compared <span class="token keyword">for</span> emit<span class="token punctuation">]</span> <span class="token punctuation">(</span>name: shared<span class="token punctuation">)</span>\nasset runtime.bundle.js <span class="token number">7.79</span> KiB <span class="token punctuation">[</span>compared <span class="token keyword">for</span> emit<span class="token punctuation">]</span> <span class="token punctuation">(</span>name: runtime<span class="token punctuation">)</span>\nasset index.bundle.js <span class="token number">1.77</span> KiB <span class="token punctuation">[</span>compared <span class="token keyword">for</span> emit<span class="token punctuation">]</span> <span class="token punctuation">(</span>name: index<span class="token punctuation">)</span>\nasset another.bundle.js <span class="token number">1.65</span> KiB <span class="token punctuation">[</span>compared <span class="token keyword">for</span> emit<span class="token punctuation">]</span> <span class="token punctuation">(</span>name: another<span class="token punctuation">)</span>\nEntrypoint index <span class="token number">1.77</span> KiB <span class="token operator">=</span> index.bundle.js\nEntrypoint another <span class="token number">1.65</span> KiB <span class="token operator">=</span> another.bundle.js\nEntrypoint shared <span class="token number">557</span> KiB <span class="token operator">=</span> runtime.bundle.js <span class="token number">7.79</span> KiB shared.bundle.js <span class="token number">549</span> KiB\nruntime modules <span class="token number">3.76</span> KiB <span class="token number">7</span> modules\ncacheable modules <span class="token number">530</span> KiB\n  ./node_modules/lodash/lodash.js <span class="token number">530</span> KiB <span class="token punctuation">[</span>built<span class="token punctuation">]</span> <span class="token punctuation">[</span>code generated<span class="token punctuation">]</span>\n  ./src/another-module.js <span class="token number">84</span> bytes <span class="token punctuation">[</span>built<span class="token punctuation">]</span> <span class="token punctuation">[</span>code generated<span class="token punctuation">]</span>\n  ./src/index.js <span class="token number">257</span> bytes <span class="token punctuation">[</span>built<span class="token punctuation">]</span> <span class="token punctuation">[</span>code generated<span class="token punctuation">]</span>\nwebpack <span class="token number">5.4</span>.0 compiled successfully <span class="token keyword">in</span> <span class="token number">249</span> ms</code></pre> <p>由上可知，除了生成 <code>shared.bundle.js</code>，<code>index.bundle.js</code> 和 <code>another.bundle.js</code> 之外，还生成了一个 <code>runtime.bundle.js</code> 文件。</p> <p>尽管可以在 webpack 中允许每个页面使用多入口，应尽可能避免使用多入口的入口：<code>entry: { page: [\'./analytics\', \'./app\'] }</code>。如此，在使用 <code>async</code> 脚本标签时，会有更好的优化以及一致的执行顺序。</p> <h3 id="splitchunksplugin"><code>SplitChunksPlugin</code> <a href="#splitchunksplugin" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p><a href="plugins/split-chunks-plugin.htm"/*tpa=https://webpack.docschina.org/plugins/split-chunks-plugin*/><code>SplitChunksPlugin</code></a> 插件可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk。让我们使用这个插件，将之前的示例中重复的 <code>lodash</code> 模块去除：</p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> const path = require(\'path\');\n</span></span>\n<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> module.exports = {\n</span><span class="token prefix unchanged"> </span><span class="token line">   mode: \'development\',\n</span><span class="token prefix unchanged"> </span><span class="token line">   entry: {\n</span><span class="token prefix unchanged"> </span><span class="token line">     index: \'src/index.js\'/*tpa=https://webpack.docschina.org/src/index.js*/,\n</span><span class="token prefix unchanged"> </span><span class="token line">     another: \'src/another-module.js\'/*tpa=https://webpack.docschina.org/src/another-module.js*/,\n</span><span class="token prefix unchanged"> </span><span class="token line">   },\n</span><span class="token prefix unchanged"> </span><span class="token line">   output: {\n</span><span class="token prefix unchanged"> </span><span class="token line">     filename: \'[name].bundle.js\'/*tpa=https://webpack.docschina.org/[name].bundle.js*/,\n</span><span class="token prefix unchanged"> </span><span class="token line">     path: path.resolve(__dirname, \'dist\'),\n</span><span class="token prefix unchanged"> </span><span class="token line">   },\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   optimization: {\n</span><span class="token prefix inserted">+</span><span class="token line">     splitChunks: {\n</span><span class="token prefix inserted">+</span><span class="token line">       chunks: \'all\',\n</span><span class="token prefix inserted">+</span><span class="token line">     },\n</span><span class="token prefix inserted">+</span><span class="token line">   },\n</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> };</span></span></code></pre> <p>使用 <a href="plugins/split-chunks-plugin/index.htm#optimization-splitchunks"/*tpa=https://webpack.docschina.org/plugins/split-chunks-plugin/#optimization-splitchunks*/><code>optimization.splitChunks</code></a> 配置选项之后，现在应该可以看出，<code>index.bundle.js</code> 和 <code>another.bundle.js</code> 中已经移除了重复的依赖模块。需要注意的是，插件将 <code>lodash</code> 分离到单独的 chunk，并且将其从 main bundle 中移除，减轻了大小。执行 <code>npm run build</code> 查看效果：</p> <pre><code class="hljs language-bash"><span class="token punctuation">..</span>.\n<span class="token punctuation">[</span>webpack-cli<span class="token punctuation">]</span> Compilation finished\nasset vendors-node_modules_lodash_lodash_js.bundle.js <span class="token number">549</span> KiB <span class="token punctuation">[</span>compared <span class="token keyword">for</span> emit<span class="token punctuation">]</span> <span class="token punctuation">(</span>id hint: vendors<span class="token punctuation">)</span>\nasset index.bundle.js <span class="token number">8.92</span> KiB <span class="token punctuation">[</span>compared <span class="token keyword">for</span> emit<span class="token punctuation">]</span> <span class="token punctuation">(</span>name: index<span class="token punctuation">)</span>\nasset another.bundle.js <span class="token number">8.8</span> KiB <span class="token punctuation">[</span>compared <span class="token keyword">for</span> emit<span class="token punctuation">]</span> <span class="token punctuation">(</span>name: another<span class="token punctuation">)</span>\nEntrypoint index <span class="token number">558</span> KiB <span class="token operator">=</span> vendors-node_modules_lodash_lodash_js.bundle.js <span class="token number">549</span> KiB index.bundle.js <span class="token number">8.92</span> KiB\nEntrypoint another <span class="token number">558</span> KiB <span class="token operator">=</span> vendors-node_modules_lodash_lodash_js.bundle.js <span class="token number">549</span> KiB another.bundle.js <span class="token number">8.8</span> KiB\nruntime modules <span class="token number">7.64</span> KiB <span class="token number">14</span> modules\ncacheable modules <span class="token number">530</span> KiB\n  ./src/index.js <span class="token number">257</span> bytes <span class="token punctuation">[</span>built<span class="token punctuation">]</span> <span class="token punctuation">[</span>code generated<span class="token punctuation">]</span>\n  ./src/another-module.js <span class="token number">84</span> bytes <span class="token punctuation">[</span>built<span class="token punctuation">]</span> <span class="token punctuation">[</span>code generated<span class="token punctuation">]</span>\n  ./node_modules/lodash/lodash.js <span class="token number">530</span> KiB <span class="token punctuation">[</span>built<span class="token punctuation">]</span> <span class="token punctuation">[</span>code generated<span class="token punctuation">]</span>\nwebpack <span class="token number">5.4</span>.0 compiled successfully <span class="token keyword">in</span> <span class="token number">241</span> ms</code></pre> <p>以下是由社区提供，一些对于代码分离很有帮助的 plugin 和 loader：</p> <ul> <li><a href="plugins/mini-css-extract-plugin.htm"/*tpa=https://webpack.docschina.org/plugins/mini-css-extract-plugin*/><code>mini-css-extract-plugin</code></a>: 用于将 CSS 从主应用程序中分离。</li> </ul> <h2 id="dynamic-imports">动态导入(dynamic import) <a href="#dynamic-imports" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>当涉及到动态代码拆分时，webpack 提供了两个类似的技术。第一种，也是推荐选择的方式是，使用符合 <a href="https://github.com/tc39/proposal-dynamic-import">ECMAScript 提案</a> 的 <a href="api/module-methods/index.htm#import-1"/*tpa=https://webpack.docschina.org/api/module-methods/#import-1*/><code>import()</code> 语法</a> 来实现动态导入。第二种，则是 webpack 的遗留功能，使用 webpack 特定的 <a href="api/module-methods/index.htm#requireensure"/*tpa=https://webpack.docschina.org/api/module-methods/#requireensure*/><code>require.ensure</code></a>。让我们先尝试使用第一种……</p> <blockquote class="warning"> <p><code>import()</code> 调用会在内部用到 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promises</a>。如果在旧版本浏览器中（例如，IE 11）使用 <code>import()</code>，记得使用一个 polyfill 库（例如 <a href="https://github.com/stefanpenner/es6-promise">es6-promise</a> 或 <a href="https://github.com/taylorhakes/promise-polyfill">promise-polyfill</a>），来 shim <code>Promise</code>。</p> </blockquote> <p>在我们开始之前，先从上述示例的配置中移除掉多余的 <a href="concepts/entry-points/index.htm"/*tpa=https://webpack.docschina.org/concepts/entry-points/*/><code>entry</code></a> 和 <a href="plugins/split-chunks-plugin/index.htm#optimization-splitchunks"/*tpa=https://webpack.docschina.org/plugins/split-chunks-plugin/#optimization-splitchunks*/><code>optimization.splitChunks</code></a>，因为接下来的演示中并不需要它们：</p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">const path = require(\'path\');\n</span><span class="token prefix unchanged"> </span><span class="token line">\n</span><span class="token prefix unchanged"> </span><span class="token line">module.exports = {\n</span><span class="token prefix unchanged"> </span><span class="token line">  mode: \'development\',\n</span><span class="token prefix unchanged"> </span><span class="token line">  entry: {\n</span><span class="token prefix unchanged"> </span><span class="token line">    index: \'src/index.js\'/*tpa=https://webpack.docschina.org/src/index.js*/,\n</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    another: \'src/another-module.js\'/*tpa=https://webpack.docschina.org/src/another-module.js*/,\n</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  },\n</span><span class="token prefix unchanged"> </span><span class="token line">  output: {\n</span><span class="token prefix unchanged"> </span><span class="token line">    filename: \'[name].bundle.js\'/*tpa=https://webpack.docschina.org/[name].bundle.js*/,\n</span><span class="token prefix unchanged"> </span><span class="token line">    path: path.resolve(__dirname, \'dist\'),\n</span><span class="token prefix unchanged"> </span><span class="token line">  },\n</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  optimization: {\n</span><span class="token prefix deleted">-</span><span class="token line">    splitChunks: {\n</span><span class="token prefix deleted">-</span><span class="token line">      chunks: \'all\',\n</span><span class="token prefix deleted">-</span><span class="token line">    },\n</span><span class="token prefix deleted">-</span><span class="token line">  },\n</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">};</span></span></code></pre> <p>我们将更新我们的项目，移除现在未使用的文件：</p> <p><strong>project</strong></p> <pre><code class="hljs language-diff">webpack-demo\n|- package.json\n|- webpack.config.js\n|- /dist\n|- /src\n<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> |- index.js\n</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> |- another-module.js\n</span></span>|- /node_modules</code></pre> <p>现在，我们不再使用 statically import(静态导入) <code>lodash</code>，而是通过 dynamic import(动态导入) 来分离出一个 chunk：</p> <p><strong>src/index.js</strong></p> <pre><code class="hljs language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">import _ from \'lodash\';\n</span><span class="token prefix deleted">-</span><span class="token line">\n</span><span class="token prefix deleted">-</span><span class="token line">function component() {\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">function getComponent() {\n</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  const element = document.createElement(\'div\');\n</span><span class="token prefix unchanged"> </span><span class="token line">\n</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  // Lodash, now imported by this script\n</span><span class="token prefix deleted">-</span><span class="token line">  element.innerHTML = _.join([\'Hello\', \'webpack\'], \' \');\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return import(\'lodash\')\n</span><span class="token prefix inserted">+</span><span class="token line">    .then(({ default: _ }) => {\n</span><span class="token prefix inserted">+</span><span class="token line">      const element = document.createElement(\'div\');\n</span><span class="token prefix inserted">+</span><span class="token line">\n</span><span class="token prefix inserted">+</span><span class="token line">      element.innerHTML = _.join([\'Hello\', \'webpack\'], \' \');\n</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">\n</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  return element;\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      return element;\n</span><span class="token prefix inserted">+</span><span class="token line">    })\n</span><span class="token prefix inserted">+</span><span class="token line">    .catch((error) => \'An error occurred while loading the component\');\n</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">}\n</span><span class="token prefix unchanged"> </span><span class="token line">\n</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">document.body.appendChild(component());\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">getComponent().then((component) => {\n</span><span class="token prefix inserted">+</span><span class="token line">  document.body.appendChild(component);\n</span><span class="token prefix inserted">+</span><span class="token line">});</span></span></code></pre> <p>我们之所以需要 <code>default</code>，是因为 webpack 4 在导入 CommonJS 模块时，将不再解析为 <code>module.exports</code> 的值，而是为 CommonJS 模块创建一个 artificial namespace 对象，更多有关背后原因的信息，请阅读 <a href="https://medium.com/webpack/webpack-4-import-and-commonjs-d619d626b655">webpack 4: import() and CommonJs</a>。</p> <p>让我们执行 webpack，查看 <code>lodash</code> 是否会分离到一个单独的 bundle：</p> <pre><code class="hljs language-bash"><span class="token punctuation">..</span>.\n<span class="token punctuation">[</span>webpack-cli<span class="token punctuation">]</span> Compilation finished\nasset vendors-node_modules_lodash_lodash_js.bundle.js <span class="token number">549</span> KiB <span class="token punctuation">[</span>compared <span class="token keyword">for</span> emit<span class="token punctuation">]</span> <span class="token punctuation">(</span>id hint: vendors<span class="token punctuation">)</span>\nasset index.bundle.js <span class="token number">13.5</span> KiB <span class="token punctuation">[</span>compared <span class="token keyword">for</span> emit<span class="token punctuation">]</span> <span class="token punctuation">(</span>name: index<span class="token punctuation">)</span>\nruntime modules <span class="token number">7.37</span> KiB <span class="token number">11</span> modules\ncacheable modules <span class="token number">530</span> KiB\n  ./src/index.js <span class="token number">434</span> bytes <span class="token punctuation">[</span>built<span class="token punctuation">]</span> <span class="token punctuation">[</span>code generated<span class="token punctuation">]</span>\n  ./node_modules/lodash/lodash.js <span class="token number">530</span> KiB <span class="token punctuation">[</span>built<span class="token punctuation">]</span> <span class="token punctuation">[</span>code generated<span class="token punctuation">]</span>\nwebpack <span class="token number">5.4</span>.0 compiled successfully <span class="token keyword">in</span> <span class="token number">268</span> ms</code></pre> <p>由于 <code>import()</code> 会返回一个 promise，因此它可以和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function"><code>async</code> 函数</a>一起使用。下面是如何通过 async 函数简化代码：</p> <p><strong>src/index.js</strong></p> <pre><code class="hljs language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">function getComponent() {\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">async function getComponent() {\n</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  const element = document.createElement(\'div\');\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  const { default: _ } = await import(\'lodash\');\n</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">\n</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  return import(\'lodash\')\n</span><span class="token prefix deleted">-</span><span class="token line">    .then(({ default: _ }) => {\n</span><span class="token prefix deleted">-</span><span class="token line">      const element = document.createElement(\'div\');\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  element.innerHTML = _.join([\'Hello\', \'webpack\'], \' \');\n</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">\n</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">      element.innerHTML = _.join([\'Hello\', \'webpack\'], \' \');\n</span><span class="token prefix deleted">-</span><span class="token line">\n</span><span class="token prefix deleted">-</span><span class="token line">      return element;\n</span><span class="token prefix deleted">-</span><span class="token line">    })\n</span><span class="token prefix deleted">-</span><span class="token line">    .catch((error) => \'An error occurred while loading the component\');\n</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  return element;\n</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">}\n</span><span class="token prefix unchanged"> </span><span class="token line">\n</span><span class="token prefix unchanged"> </span><span class="token line">getComponent().then((component) => {\n</span><span class="token prefix unchanged"> </span><span class="token line">  document.body.appendChild(component);\n</span><span class="token prefix unchanged"> </span><span class="token line">});</span></span></code></pre> <blockquote class="tip"> <p>在稍后示例中，可能会根据计算后的变量(computed variable)导入特定模块时，可以通过向 <code>import()</code> 传入一个 <a href="api/module-methods/index.htm#dynamic-expressions-in-import"/*tpa=https://webpack.docschina.org/api/module-methods/#dynamic-expressions-in-import*/>动态表达式</a>。</p> </blockquote> <h2 id="prefetchingpreloading-modules">预获取/预加载模块(prefetch/preload module) <a href="#prefetchingpreloading-modules" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>webpack v4.6.0+ 增加了对预获取和预加载的支持。</p> <p>在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 "resource hint(资源提示)"，来告知浏览器：</p> <ul> <li><strong>prefetch</strong>(预获取)：将来某些导航下可能需要的资源</li> <li><strong>preload</strong>(预加载)：当前导航下可能需要资源</li> </ul> <p>下面这个 prefetch 的简单示例中，有一个 <code>HomePage</code> 组件，其内部渲染一个 <code>LoginButton</code> 组件，然后在点击后按需加载 <code>LoginModal</code> 组件。</p> <p><strong>LoginButton.js</strong></p> <pre><code class="hljs language-js"><span class="token comment">//...</span>\n<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackPrefetch: true */</span> <span class="token string">\'path/to/LoginModal.js\'/*tpa=https://webpack.docschina.org/path/to/LoginModal.js*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p>这会生成 <code>&#x3C;link rel="prefetch" href="login-modal-chunk.js"/*tpa=https://webpack.docschina.org/login-modal-chunk.js*/></code> 并追加到页面头部，指示着浏览器在闲置时间预取 <code>login-modal-chunk.js</code> 文件。</p> <blockquote class="tip"> <p>只要父 chunk 完成加载，webpack 就会添加 prefetch hint(预取提示)。</p> </blockquote> <p>与 prefetch 指令相比，preload 指令有许多不同之处：</p> <ul> <li>preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。</li> <li>preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。</li> <li>preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻。</li> <li>浏览器支持程度不同。</li> </ul> <p>下面这个简单的 preload 示例中，有一个 <code>Component</code>，依赖于一个较大的 library，所以应该将其分离到一个独立的 chunk 中。</p> <p>我们假想这里的图表组件 <code>ChartComponent</code> 组件需要依赖体积巨大的 <code>ChartingLibrary</code> 库。它会在渲染时显示一个 <code>LoadingIndicator(加载进度条)</code> 组件，然后立即按需导入 <code>ChartingLibrary</code>：</p> <p><strong>ChartComponent.js</strong></p> <pre><code class="hljs language-js"><span class="token comment">//...</span>\n<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackPreload: true */</span> <span class="token string">\'ChartingLibrary\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p>在页面中使用 <code>ChartComponent</code> 时，在请求 ChartComponent.js 的同时，还会通过 <code>&#x3C;link rel="preload"></code> 请求 charting-library-chunk。假定 page-chunk 体积很小，很快就被加载好，页面此时就会显示 <code>LoadingIndicator(加载进度条)</code> ，等到 <code>charting-library-chunk</code> 请求完成，LoadingIndicator 组件才消失。启动仅需要很少的加载时间，因为只进行单次往返，而不是两次往返。尤其是在高延迟环境下。</p> <blockquote class="tip"> <p>不正确地使用 <code>webpackPreload</code> 会有损性能，请谨慎使用。</p> </blockquote> <h2 id="bundle-analysis">bundle 分析(bundle analysis) <a href="#bundle-analysis" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>一旦开始分离代码，一件很有帮助的事情是，分析输出结果来检查模块在何处结束。 <a href="https://github.com/webpack/analyse">官方分析工具</a> 是一个不错的开始。还有一些其他社区支持的可选项：</p> <ul> <li><a href="https://alexkuz.github.io/webpack-chart/">webpack-chart</a>: webpack stats 可交互饼图。</li> <li><a href="https://chrisbateman.github.io/webpack-visualizer/">webpack-visualizer</a>: 可视化并分析你的 bundle，检查哪些模块占用空间，哪些可能是重复使用的。</li> <li><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">webpack-bundle-analyzer</a>：一个 plugin 和 CLI 工具，它将 bundle 内容展示为一个便捷的、交互式、可缩放的树状图形式。</li> <li><a href="https://webpack.jakoblind.no/optimize">webpack bundle optimize helper</a>：这个工具会分析你的 bundle，并提供可操作的改进措施，以减少 bundle 的大小。</li> <li><a href="https://github.com/bundle-stats/bundle-stats">bundle-stats</a>：生成一个 bundle 报告（bundle 大小、资源、模块），并比较不同构建之间的结果。</li> </ul> <h2 id="next-steps">下一步 <a href="#next-steps" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>接下来，查看 <a href="guides/lazy-loading/index.htm"/*tpa=https://webpack.docschina.org/guides/lazy-loading/*/>延迟加载</a> 来学习如何在实际一个真实应用程序中使用 <code>import()</code> 的具体示例，以及查看 <a href="guides/caching/index.htm"/*tpa=https://webpack.docschina.org/guides/caching/*/>缓存</a> 来学习如何有效地分离代码。</p> '}}]);