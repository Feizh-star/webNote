<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta name="theme-color" content="#2B3A42"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="robots" content="noindex,nofollow"/><title>webpack 官方中文文档</title><meta name="description" content="webpack 是一个模块打包器。它的主要目标是将 JavaScript 文件打包在一起，打包后的文件用于在浏览器中使用，但它也能够胜任转换（transform）、打包（bundle）或包裹（package）任何资源(resource or asset)。"/><meta property="og:site_name" content="webpack"/><meta property="og:type" content="website"/><meta property="og:title" content="webpack 官方中文文档"/><meta property="og:description" name="description" content="webpack 是一个模块打包器。它的主要目标是将 JavaScript 文件打包在一起，打包后的文件用于在浏览器中使用，但它也能够胜任转换（transform）、打包（bundle）或包裹（package）任何资源(resource or asset)。"/><meta property="og:image" content="https://webpack.js.org/icon-pwa-512x512.d3dae4189855b3a72ff9.png"/><meta property="twitter:card" content="summary"/><meta property="twitter:site" content="@webpack"/><meta property="twitter:creator" content="@webpack"/><meta property="twitter:domain" content="https://webpack.js.org/"/><meta name="keywords" content="webpack5, webpack, webpack 中文文档, 印记中文, docschina, docschina.org, webpack.docschina.org, doc.react-china.org, nodejs.cn, vue.docschina.org, babel.docschina.org, parceljs.docschina.org, rollup.docschina.org, koajs.docschina.org"/><link rel="icon" type="image/x-icon" href="/favicon.f326220248556af65f41.ico"/><link rel="stylesheet" href="../../index.62a0b2891bdf09ef93b2.css" tppabs="https://webpack.docschina.org/index.62a0b2891bdf09ef93b2.css"/><link rel="manifest" href="/manifest.json"/><link rel="canonical" href="https://webpack.js.org/concepts/printable/"/><meta name="mobile-web-app-capable" content="yes"/><link rel="icon" sizes="192x192" href="/icon_192x192.png"/><link rel="icon" sizes="512x512" href="/icon_512x512.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="apple-mobile-web-app-title" content="webpack"/><link rel="apple-touch-icon" href="/icon_180x180.png"/><link rel="mask-icon" href="/logo-on-white-bg.47eff95f9c01c5972f6f.svg" color="#465e69"/><meta name="msapplication-TileImage" content="/icon_150x150.png"/><meta name="msapplication-TileColor" content="#465e69"/></head><body><div id="root"><div class="site"><div class="site__header"><div class="notification-bar"><div class="container notification-bar__inner"><p>Webpack 5 现已正式发布。请阅读我们的 <a href="../../blog/2020-10-10-webpack-5-release/index.htm" tppabs="https://webpack.docschina.org/blog/2020-10-10-webpack-5-release/">发布公告</a>。如还未准备升级，请阅读 <a href="javascript:if(confirm('https://v4.webpack.docschina.org/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://v4.webpack.docschina.org/'" tppabs="https://v4.webpack.docschina.org/">webpack 4 文档</a>。</p></div></div><header class="navigation   "><section class="navigation__inner"><button aria-label="Open menu" class="navigation__mobile"><svg viewBox="-62 138 25 25"><g><g><path d="M-60.2,140.2h20.9c1,0,1.8,0.8,1.8,1.8l0,0c0,1-0.8,1.8-1.8,1.8h-20.9c-1,0-1.8-0.8-1.8-1.8l0,0 C-62,141-61.2,140.2-60.2,140.2z"></path><path d="M-60.2,148.7h20.9c1,0,1.8,0.8,1.8,1.8l0,0c0,1-0.8,1.8-1.8,1.8h-20.9c-1,0-1.8-0.8-1.8-1.8l0,0 C-62,149.5-61.2,148.7-60.2,148.7z"></path><path d="M-60.2,157.2h20.9c1,0,1.8,0.8,1.8,1.8l0,0c0,1-0.8,1.8-1.8,1.8h-20.9c-1,0-1.8-0.8-1.8-1.8l0,0 C-62,158-61.2,157.2-60.2,157.2z"></path></g></g></svg></button><a class="navigation__logo" href="../../index-1.htm" tppabs="https://webpack.docschina.org/"><img class="logo" src="../../site-logo.1fcab817090e78435061.svg" tppabs="https://webpack.docschina.org/site-logo.1fcab817090e78435061.svg" alt="webpack logo"/></a><nav class="navigation__items"><a class="navigation__item  navigation__item--active" href="../index.htm" tppabs="https://webpack.docschina.org/concepts/">中文文档</a><a class="navigation__item  " href="../../contribute/index.htm" tppabs="https://webpack.docschina.org/contribute/">参与贡献</a><a class="navigation__item  " href="../../vote/index.htm" tppabs="https://webpack.docschina.org/vote/">投票</a><a class="navigation__item  " href="../../blog/index.htm" tppabs="https://webpack.docschina.org/blog/">博客</a><a href="javascript:if(confirm('https://docschina.org/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://docschina.org/'" tppabs="https://docschina.org/" target="_blank" rel="noopener noreferrer" class="navigation__item  ">印记中文</a><a href="javascript:if(confirm('https://github.com/webpack/webpack  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/webpack/webpack'" tppabs="https://github.com/webpack/webpack" target="_blank" rel="noopener noreferrer" title="GitHub Repository" class="navigation__item navigation__item--icon "><svg viewBox="0 0 24 24" aria-hidden="true" fill="#fff" width="16"><path d="M12 2A10 10 0 002 12a10 10 0 006.8 9.5c.5 0 .7-.2.7-.5v-1.7C6.7 20 6.1 18 6.1 18c-.4-1.2-1-1.5-1-1.5-1-.6 0-.6 0-.6 1 0 1.5 1 1.5 1 .9 1.6 2.4 1.1 3 .9 0-.7.3-1.1.6-1.4-2.2-.2-4.6-1-4.6-4.9 0-1.1.4-2 1-2.7 0-.3-.4-1.3.2-2.7 0 0 .8-.2 2.7 1a9.4 9.4 0 015 0c2-1.2 2.8-1 2.8-1 .5 1.4.1 2.4 0 2.7.7.7 1 1.6 1 2.7 0 3.8-2.3 4.7-4.5 5 .4.2.7.8.7 1.8V21c0 .3.2.6.7.5 4-1.3 6.8-5 6.8-9.5A10 10 0 0012 2z"></path></svg></a><a href="javascript:if(confirm('https://twitter.com/webpack  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://twitter.com/webpack'" tppabs="https://twitter.com/webpack" target="_blank" rel="noopener noreferrer" title="webpack on Twitter" class="navigation__item navigation__item--icon "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 30" aria-hidden="true" fill="#fff" width="16"><path d="M28 6.937c-.957.425-1.985.711-3.064.84a5.343 5.343 0 002.345-2.951 10.696 10.696 0 01-3.388 1.295 5.334 5.334 0 00-9.089 4.864A15.143 15.143 0 013.809 5.411a5.321 5.321 0 00-.721 2.683 5.33 5.33 0 002.372 4.439 5.323 5.323 0 01-2.416-.667v.067a5.335 5.335 0 004.279 5.23 5.336 5.336 0 01-2.409.092 5.34 5.34 0 004.983 3.705 10.699 10.699 0 01-6.625 2.284c-.43 0-.855-.025-1.273-.075a15.102 15.102 0 008.177 2.396c9.812 0 15.176-8.128 15.176-15.177 0-.231-.005-.461-.015-.69A10.855 10.855 0 0028 6.937z"></path></svg></a><a href="javascript:if(confirm('https://stackoverflow.com/questions/tagged/webpack  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://stackoverflow.com/questions/tagged/webpack'" tppabs="https://stackoverflow.com/questions/tagged/webpack" target="_blank" rel="noopener noreferrer" title="webpack on Stack Overflow" class="navigation__item navigation__item--icon "><svg viewBox="0 0 24 24" aria-hidden="true" fill="#fff" width="16"><path d="M17.4 20.2v-5.4h1.8V22H3v-7.2h1.8v5.4h12.6M6.8 14.3l.3-1.7 8.8 1.8-.3 1.8-8.8-1.9m1.1-4.2l.8-1.6 8.1 3.8-.7 1.6-8.2-3.8m2.3-4l1.1-1.4 7 5.8-1.2 1.4L10 6m4.7-4L20 9l-1.4 1-5.4-7 1.4-1m-8 16.5v-1.8h9v1.8h-9z"></path></svg></a><span class="navigation__item navigation__item--icon"><nav class="dropdown navigation__languages"><button aria-haspopup="true" aria-expanded="false" aria-label="Select language"><img class="dropdown__language" alt="select language" src="../../language-icon.87a028c9bf555eeb5932.svg" tppabs="https://webpack.docschina.org/language-icon.87a028c9bf555eeb5932.svg"/><i aria-hidden="true" class="dropdown__arrow"></i></button><div class="dropdown__list "><ul><li><a href="javascript:if(confirm('https://webpack.js.org/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://webpack.js.org/'" tppabs="https://webpack.js.org/"><span>English</span></a></li><li><a href="../../index-1.htm" tppabs="https://webpack.docschina.org/"><span lang="zh">中文</span></a></li></ul></div></nav></span></nav><div class="navigation-search "><input type="text" class="navigation-search__input" placeholder="Search this site..." value=""/><button aria-label="Hide search box" class="navigation-search__icon navigation-search__clear"><svg viewBox="-137 138 25 25"><g transform="translate(0,-952.36218)"><path d="M-131.3,1094.4c-0.4,0-0.9,0.1-1.2,0.5c-0.7,0.7-0.7,1.7,0,2.4l5.6,5.6l-5.6,5.6c-0.7,0.7-0.7,1.7,0,2.4 c0.7,0.7,1.7,0.7,2.4,0l5.6-5.6l5.6,5.6c0.7,0.7,1.7,0.7,2.4,0c0.7-0.7,0.7-1.7,0-2.4l-5.6-5.6l5.6-5.6c0.7-0.7,0.7-1.7,0-2.4 c-0.7-0.7-1.7-0.7-2.4,0l-5.6,5.6l-5.6-5.6C-130.5,1094.5-130.9,1094.4-131.3,1094.4L-131.3,1094.4z"></path></g></svg></button><button aria-label="Show search box" class="navigation-search__icon navigation-search__search"><svg viewBox="-137 138 25 25"><g><path d="M-114.6,162.6l-7.5-7.5c-0.6-0.6-0.6-1.6,0-2.1l0,0c0.6-0.6,1.6-0.6,2.1,0l7.5,7.5c0.6,0.6,0.6,1.6,0,2.1l0,0 C-113,163.1-114,163.1-114.6,162.6z"></path><path d="M-134.1,140.9c-3.9,3.9-3.9,10.2,0,14.1s10.2,3.9,14.1,0s3.9-10.2,0-14.1S-130.2,137-134.1,140.9z M-122.1,153 c-2.7,2.7-7.1,2.7-9.8,0s-2.7-7.1,0-9.8s7.1-2.7,9.8,0C-119.4,145.9-119.4,150.2-122.1,153z"></path></g></svg></button></div></section><div class="navigation-sub"><div class="navigation-sub__inner"><a class="navigation-sub__link " title="api" content="api" href="../../api/index.htm" tppabs="https://webpack.docschina.org/api/">api</a><a class="navigation-sub__link " title="blog" content="blog" href="../../blog/index.htm" tppabs="https://webpack.docschina.org/blog/">blog</a><a class="navigation-sub__link navigation-sub__link--active" title="概念" content="概念" href="../index.htm" tppabs="https://webpack.docschina.org/concepts/">概念</a><a class="navigation-sub__link " title="配置" content="配置" href="../../configuration/index.htm" tppabs="https://webpack.docschina.org/configuration/">配置</a><a class="navigation-sub__link " title="指南" content="指南" href="../../guides/index.htm" tppabs="https://webpack.docschina.org/guides/">指南</a><a class="navigation-sub__link " title="loader" content="loader" href="../../loaders/index.htm" tppabs="https://webpack.docschina.org/loaders/">loader</a><a class="navigation-sub__link " title="迁移" content="迁移" href="../../migrate/index.htm" tppabs="https://webpack.docschina.org/migrate/">迁移</a><a class="navigation-sub__link " title="plugin" content="plugin" href="../../plugins/index.htm" tppabs="https://webpack.docschina.org/plugins/">plugin</a></div></div></header></div><div class="container site__content"><div class="sponsors"><a href="javascript:if(confirm('https://www.ag-grid.com/?utm_source=webpack&utm_medium=banner&utm_campaign=sponsorship  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://www.ag-grid.com/?utm_source=webpack&utm_medium=banner&utm_campaign=sponsorship'" tppabs="https://www.ag-grid.com/?utm_source=webpack&utm_medium=banner&utm_campaign=sponsorship" target="_blank" rel="noopener noreferrer" class="sponsors__content"><img src="../../ag-grid-logo.4fe9d34532b2c0821fc9.png" tppabs="https://webpack.docschina.org/ag-grid-logo.4fe9d34532b2c0821fc9.png"/><img class="sponsors__img__webpack" src="../../icon-square-small.85ba630cf0c5f29ae3e3.svg" tppabs="https://webpack.docschina.org/icon-square-small.85ba630cf0c5f29ae3e3.svg"/><div class="sponsors__content-cont">ag-grid is proud to partner with webpack</div></a></div><nav class="sidebar site__sidebar"><div class="sidebar__inner"><div class="sidebar__shields"><a href="javascript:if(confirm('https://github.com/webpack/webpack/releases  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/webpack/webpack/releases'" tppabs="https://github.com/webpack/webpack/releases"><img alt="webpack shield" src="../../../img.shields.io/github/package-json/v/webpack/webpack.svg-label=webpack&style=flat-square&maxAge=3600" tppabs="https://img.shields.io/github/package-json/v/webpack/webpack.svg?label=webpack&style=flat-square&maxAge=3600"/></a></div><div class="sidebar-item sidebar-item--disabled`"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" class="sidebar-item__toggle" width="15" height="17" fill="#175d96"><path d="M10 3.3c-.6 0-1 .4-1.1 1.1v11.2c0 .3.2.6.4.8.2.2.5.4.8.4.6 0 1-.4 1.1-1.1V4.5c0-.3-.2-.6-.4-.8-.2-.2-.5-.4-.8-.4z" color="#000" style="isolation:auto;mix-blend-mode:normal"></path></svg><a class="sidebar-item__title sidebar-link__print" href="index.htm" tppabs="https://webpack.docschina.org/concepts/printable/" rel="nofollow noopener noreferrer" alt="Print" title="Print" target="_blank">Print Section<img src="../../icon-print.42ad40feec51e6f5f553.svg" tppabs="https://webpack.docschina.org/icon-print.42ad40feec51e6f5f553.svg"/></a></div><div><div class="sidebar-item  "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="15" height="17" fill="#175d96" class="sidebar-item__toggle"><path d="M9.2 4.5l4.5 4.7c.2.2.3.5.3.8s-.1.6-.3.8l-4.5 4.7c-.5.4-1.2.4-1.7 0-.4-.5-.4-1 0-1.6l3.8-3.9-3.8-4c-.4-.4-.4-1 0-1.5.5-.4 1.2-.4 1.7 0z"></path></svg><a class="sidebar-item__title" href="../index.htm" tppabs="https://webpack.docschina.org/concepts/">概念</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="入口(entry)"><a href="../index.htm#entry" tppabs="https://webpack.docschina.org/concepts/#entry">入口(entry)</a></li><li class="sidebar-item__anchor" title="输出(output)"><a href="../index.htm#output" tppabs="https://webpack.docschina.org/concepts/#output">输出(output)</a></li><li class="sidebar-item__anchor" title="loader"><a href="../index.htm#loaders" tppabs="https://webpack.docschina.org/concepts/#loaders">loader</a></li><li class="sidebar-item__anchor" title="插件(plugin)"><a href="../index.htm#plugins" tppabs="https://webpack.docschina.org/concepts/#plugins">插件(plugin)</a></li><li class="sidebar-item__anchor" title="模式(mode)"><a href="../index.htm#mode" tppabs="https://webpack.docschina.org/concepts/#mode">模式(mode)</a></li><li class="sidebar-item__anchor" title="浏览器兼容性(browser compatibility)"><a href="../index.htm#browser-compatibility" tppabs="https://webpack.docschina.org/concepts/#browser-compatibility">浏览器兼容性(browser compatibility)</a></li><li class="sidebar-item__anchor" title="环境(environment)"><a href="../index.htm#environment" tppabs="https://webpack.docschina.org/concepts/#environment">环境(environment)</a></li></ul></div></div><div><div class="sidebar-item  "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="15" height="17" fill="#175d96" class="sidebar-item__toggle"><path d="M9.2 4.5l4.5 4.7c.2.2.3.5.3.8s-.1.6-.3.8l-4.5 4.7c-.5.4-1.2.4-1.7 0-.4-.5-.4-1 0-1.6l3.8-3.9-3.8-4c-.4-.4-.4-1 0-1.5.5-.4 1.2-.4 1.7 0z"></path></svg><a class="sidebar-item__title" href="../entry-points/index.htm" tppabs="https://webpack.docschina.org/concepts/entry-points/">入口起点(entry points)</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="单个入口（简写）语法"><a href="../entry-points/index.htm#single-entry-shorthand-syntax" tppabs="https://webpack.docschina.org/concepts/entry-points/#single-entry-shorthand-syntax">单个入口（简写）语法</a></li><li class="sidebar-item__anchor" title="对象语法"><a href="../entry-points/index.htm#object-syntax" tppabs="https://webpack.docschina.org/concepts/entry-points/#object-syntax">对象语法</a></li><li class="sidebar-item__anchor" title="常见场景"><a href="../entry-points/index.htm#scenarios" tppabs="https://webpack.docschina.org/concepts/entry-points/#scenarios">常见场景</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="分离 app(应用程序) 和 vendor(第三方库) 入口"><a href="../entry-points/index.htm#separate-app-and-vendor-entries" tppabs="https://webpack.docschina.org/concepts/entry-points/#separate-app-and-vendor-entries">分离 app(应用程序) 和 vendor(第三方库) 入口</a></li><li class="sidebar-item__anchor" title="多页面应用程序"><a href="../entry-points/index.htm#multi-page-application" tppabs="https://webpack.docschina.org/concepts/entry-points/#multi-page-application">多页面应用程序</a></li></ul></li></ul></div></div><div><div class="sidebar-item  "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="15" height="17" fill="#175d96" class="sidebar-item__toggle"><path d="M9.2 4.5l4.5 4.7c.2.2.3.5.3.8s-.1.6-.3.8l-4.5 4.7c-.5.4-1.2.4-1.7 0-.4-.5-.4-1 0-1.6l3.8-3.9-3.8-4c-.4-.4-.4-1 0-1.5.5-.4 1.2-.4 1.7 0z"></path></svg><a class="sidebar-item__title" href="../output/index.htm" tppabs="https://webpack.docschina.org/concepts/output/">输出(output)</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="用法"><a href="../output/index.htm#usage" tppabs="https://webpack.docschina.org/concepts/output/#usage">用法</a></li><li class="sidebar-item__anchor" title="多个入口起点"><a href="../output/index.htm#multiple-entry-points" tppabs="https://webpack.docschina.org/concepts/output/#multiple-entry-points">多个入口起点</a></li><li class="sidebar-item__anchor" title="高级进阶"><a href="../output/index.htm#advanced" tppabs="https://webpack.docschina.org/concepts/output/#advanced">高级进阶</a></li></ul></div></div><div><div class="sidebar-item  "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="15" height="17" fill="#175d96" class="sidebar-item__toggle"><path d="M9.2 4.5l4.5 4.7c.2.2.3.5.3.8s-.1.6-.3.8l-4.5 4.7c-.5.4-1.2.4-1.7 0-.4-.5-.4-1 0-1.6l3.8-3.9-3.8-4c-.4-.4-.4-1 0-1.5.5-.4 1.2-.4 1.7 0z"></path></svg><a class="sidebar-item__title" href="../loaders/index.htm" tppabs="https://webpack.docschina.org/concepts/loaders/">loader</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="示例"><a href="../loaders/index.htm#example" tppabs="https://webpack.docschina.org/concepts/loaders/#example">示例</a></li><li class="sidebar-item__anchor" title="使用 loader"><a href="../loaders/index.htm#using-loaders" tppabs="https://webpack.docschina.org/concepts/loaders/#using-loaders">使用 loader</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="配置方式"><a href="../loaders/index.htm#configuration" tppabs="https://webpack.docschina.org/concepts/loaders/#configuration">配置方式</a></li><li class="sidebar-item__anchor" title="内联方式"><a href="../loaders/index.htm#inline" tppabs="https://webpack.docschina.org/concepts/loaders/#inline">内联方式</a></li><li class="sidebar-item__anchor" title="CLI 方式"><a href="../loaders/index.htm#cli" tppabs="https://webpack.docschina.org/concepts/loaders/#cli">CLI 方式</a></li></ul></li><li class="sidebar-item__anchor" title="loader 特性"><a href="../loaders/index.htm#loader-features" tppabs="https://webpack.docschina.org/concepts/loaders/#loader-features">loader 特性</a></li><li class="sidebar-item__anchor" title="解析 loader"><a href="../loaders/index.htm#resolving-loaders" tppabs="https://webpack.docschina.org/concepts/loaders/#resolving-loaders">解析 loader</a></li></ul></div></div><div><div class="sidebar-item  "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="15" height="17" fill="#175d96" class="sidebar-item__toggle"><path d="M9.2 4.5l4.5 4.7c.2.2.3.5.3.8s-.1.6-.3.8l-4.5 4.7c-.5.4-1.2.4-1.7 0-.4-.5-.4-1 0-1.6l3.8-3.9-3.8-4c-.4-.4-.4-1 0-1.5.5-.4 1.2-.4 1.7 0z"></path></svg><a class="sidebar-item__title" href="../plugins/index.htm" tppabs="https://webpack.docschina.org/concepts/plugins/">plugin</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="剖析"><a href="../plugins/index.htm#anatomy" tppabs="https://webpack.docschina.org/concepts/plugins/#anatomy">剖析</a></li><li class="sidebar-item__anchor" title="用法"><a href="../plugins/index.htm#usage" tppabs="https://webpack.docschina.org/concepts/plugins/#usage">用法</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="配置方式"><a href="../plugins/index.htm#configuration" tppabs="https://webpack.docschina.org/concepts/plugins/#configuration">配置方式</a></li><li class="sidebar-item__anchor" title="Node API 方式"><a href="../plugins/index.htm#node-api" tppabs="https://webpack.docschina.org/concepts/plugins/#node-api">Node API 方式</a></li></ul></li></ul></div></div><div><div class="sidebar-item  "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="15" height="17" fill="#175d96" class="sidebar-item__toggle"><path d="M9.2 4.5l4.5 4.7c.2.2.3.5.3.8s-.1.6-.3.8l-4.5 4.7c-.5.4-1.2.4-1.7 0-.4-.5-.4-1 0-1.6l3.8-3.9-3.8-4c-.4-.4-.4-1 0-1.5.5-.4 1.2-.4 1.7 0z"></path></svg><a class="sidebar-item__title" href="../configuration/index.htm" tppabs="https://webpack.docschina.org/concepts/configuration/">配置（Configuration）</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="基本配置"><a href="../configuration/index.htm#simple-configuration" tppabs="https://webpack.docschina.org/concepts/configuration/#simple-configuration">基本配置</a></li><li class="sidebar-item__anchor" title="多个 target"><a href="../configuration/index.htm#multiple-targets" tppabs="https://webpack.docschina.org/concepts/configuration/#multiple-targets">多个 target</a></li><li class="sidebar-item__anchor" title="使用其它配置语言"><a href="../configuration/index.htm#using-other-configuration-languages" tppabs="https://webpack.docschina.org/concepts/configuration/#using-other-configuration-languages">使用其它配置语言</a></li></ul></div></div><div><div class="sidebar-item  "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="15" height="17" fill="#175d96" class="sidebar-item__toggle"><path d="M9.2 4.5l4.5 4.7c.2.2.3.5.3.8s-.1.6-.3.8l-4.5 4.7c-.5.4-1.2.4-1.7 0-.4-.5-.4-1 0-1.6l3.8-3.9-3.8-4c-.4-.4-.4-1 0-1.5.5-.4 1.2-.4 1.7 0z"></path></svg><a class="sidebar-item__title" href="../modules/index.htm" tppabs="https://webpack.docschina.org/concepts/modules/">模块（Modules）</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="何为 webpack 模块"><a href="../modules/index.htm#what-is-a-webpack-module" tppabs="https://webpack.docschina.org/concepts/modules/#what-is-a-webpack-module">何为 webpack 模块</a></li><li class="sidebar-item__anchor" title="支持的模块类型"><a href="../modules/index.htm#supported-module-types" tppabs="https://webpack.docschina.org/concepts/modules/#supported-module-types">支持的模块类型</a></li></ul></div></div><div><div class="sidebar-item  "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="15" height="17" fill="#175d96" class="sidebar-item__toggle"><path d="M9.2 4.5l4.5 4.7c.2.2.3.5.3.8s-.1.6-.3.8l-4.5 4.7c-.5.4-1.2.4-1.7 0-.4-.5-.4-1 0-1.6l3.8-3.9-3.8-4c-.4-.4-.4-1 0-1.5.5-.4 1.2-.4 1.7 0z"></path></svg><a class="sidebar-item__title" href="../module-resolution/index.htm" tppabs="https://webpack.docschina.org/concepts/module-resolution/">模块解析（Module Resolution）</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="webpack 中的解析规则"><a href="../module-resolution/index.htm#resolving-rules-in-webpack" tppabs="https://webpack.docschina.org/concepts/module-resolution/#resolving-rules-in-webpack">webpack 中的解析规则</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="绝对路径"><a href="../module-resolution/index.htm#absolute-paths" tppabs="https://webpack.docschina.org/concepts/module-resolution/#absolute-paths">绝对路径</a></li><li class="sidebar-item__anchor" title="相对路径"><a href="../module-resolution/index.htm#relative-paths" tppabs="https://webpack.docschina.org/concepts/module-resolution/#relative-paths">相对路径</a></li><li class="sidebar-item__anchor" title="模块路径"><a href="../module-resolution/index.htm#module-paths" tppabs="https://webpack.docschina.org/concepts/module-resolution/#module-paths">模块路径</a></li></ul></li><li class="sidebar-item__anchor" title="解析 loader"><a href="../module-resolution/index.htm#resolving-loaders" tppabs="https://webpack.docschina.org/concepts/module-resolution/#resolving-loaders">解析 loader</a></li><li class="sidebar-item__anchor" title="缓存"><a href="../module-resolution/index.htm#caching" tppabs="https://webpack.docschina.org/concepts/module-resolution/#caching">缓存</a></li></ul></div></div><div><div class="sidebar-item  "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="15" height="17" fill="#175d96" class="sidebar-item__toggle"><path d="M9.2 4.5l4.5 4.7c.2.2.3.5.3.8s-.1.6-.3.8l-4.5 4.7c-.5.4-1.2.4-1.7 0-.4-.5-.4-1 0-1.6l3.8-3.9-3.8-4c-.4-.4-.4-1 0-1.5.5-.4 1.2-.4 1.7 0z"></path></svg><a class="sidebar-item__title" href="../module-federation/index.htm" tppabs="https://webpack.docschina.org/concepts/module-federation/">Module Federation</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="动机"><a href="../module-federation/index.htm#motivation" tppabs="https://webpack.docschina.org/concepts/module-federation/#motivation">动机</a></li><li class="sidebar-item__anchor" title="底层概念"><a href="../module-federation/index.htm#low-level-concepts" tppabs="https://webpack.docschina.org/concepts/module-federation/#low-level-concepts">底层概念</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="重载（Overriding）"><a href="../module-federation/index.htm#overriding" tppabs="https://webpack.docschina.org/concepts/module-federation/#overriding">重载（Overriding）</a></li></ul></li><li class="sidebar-item__anchor" title="高级概念"><a href="../module-federation/index.htm#high-level-concepts" tppabs="https://webpack.docschina.org/concepts/module-federation/#high-level-concepts">高级概念</a></li><li class="sidebar-item__anchor" title="构建块(Building blocks)"><a href="../module-federation/index.htm#building-blocks" tppabs="https://webpack.docschina.org/concepts/module-federation/#building-blocks">构建块(Building blocks)</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="OverridablesPlugin (底层 API)"><a href="../module-federation/index.htm#overridablesplugin-low-level" tppabs="https://webpack.docschina.org/concepts/module-federation/#overridablesplugin-low-level">OverridablesPlugin (底层 API)</a></li><li class="sidebar-item__anchor" title="ContainerPlugin (底层 API)"><a href="../module-federation/index.htm#containerplugin-low-level" tppabs="https://webpack.docschina.org/concepts/module-federation/#containerplugin-low-level">ContainerPlugin (底层 API)</a></li><li class="sidebar-item__anchor" title="ContainerReferencePlugin (底层 API)"><a href="../module-federation/index.htm#containerreferenceplugin-low-level" tppabs="https://webpack.docschina.org/concepts/module-federation/#containerreferenceplugin-low-level">ContainerReferencePlugin (底层 API)</a></li><li class="sidebar-item__anchor" title="ModuleFederationPlugin （高级 API）"><a href="../module-federation/index.htm#modulefederationplugin-high-level" tppabs="https://webpack.docschina.org/concepts/module-federation/#modulefederationplugin-high-level">ModuleFederationPlugin （高级 API）</a></li></ul></li><li class="sidebar-item__anchor" title="概念目标"><a href="../module-federation/index.htm#concept-goals" tppabs="https://webpack.docschina.org/concepts/module-federation/#concept-goals">概念目标</a></li><li class="sidebar-item__anchor" title="用例"><a href="../module-federation/index.htm#use-cases" tppabs="https://webpack.docschina.org/concepts/module-federation/#use-cases">用例</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="每个页面单独构建"><a href="../module-federation/index.htm#separate-builds-per-page" tppabs="https://webpack.docschina.org/concepts/module-federation/#separate-builds-per-page">每个页面单独构建</a></li><li class="sidebar-item__anchor" title="将组件库作为容器"><a href="../module-federation/index.htm#components-library-as-container" tppabs="https://webpack.docschina.org/concepts/module-federation/#components-library-as-container">将组件库作为容器</a></li></ul></li><li class="sidebar-item__anchor" title="动态远程容器"><a href="../module-federation/index.htm#dynamic-remote-containers" tppabs="https://webpack.docschina.org/concepts/module-federation/#dynamic-remote-containers">动态远程容器</a></li><li class="sidebar-item__anchor" title="故障排除"><a href="../module-federation/index.htm#troubleshooting" tppabs="https://webpack.docschina.org/concepts/module-federation/#troubleshooting">故障排除</a></li></ul></div></div><div><div class="sidebar-item  sidebar-item--disabled"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" class="sidebar-item__toggle" width="15" height="17" fill="#175d96"><path d="M10 3.3c-.6 0-1 .4-1.1 1.1v11.2c0 .3.2.6.4.8.2.2.5.4.8.4.6 0 1-.4 1.1-1.1V4.5c0-.3-.2-.6-.4-.8-.2-.2-.5-.4-.8-.4z" color="#000" style="isolation:auto;mix-blend-mode:normal"></path></svg><a class="sidebar-item__title" href="../dependency-graph/index.htm" tppabs="https://webpack.docschina.org/concepts/dependency-graph/">依赖图(dependency graph)</a></div></div><div><div class="sidebar-item  "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="15" height="17" fill="#175d96" class="sidebar-item__toggle"><path d="M9.2 4.5l4.5 4.7c.2.2.3.5.3.8s-.1.6-.3.8l-4.5 4.7c-.5.4-1.2.4-1.7 0-.4-.5-.4-1 0-1.6l3.8-3.9-3.8-4c-.4-.4-.4-1 0-1.5.5-.4 1.2-.4 1.7 0z"></path></svg><a class="sidebar-item__title" href="../targets/index.htm" tppabs="https://webpack.docschina.org/concepts/targets/">target</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="用法"><a href="../targets/index.htm#usage" tppabs="https://webpack.docschina.org/concepts/targets/#usage">用法</a></li><li class="sidebar-item__anchor" title="多 target"><a href="../targets/index.htm#multiple-targets" tppabs="https://webpack.docschina.org/concepts/targets/#multiple-targets">多 target</a></li><li class="sidebar-item__anchor" title="资源"><a href="../targets/index.htm#resources" tppabs="https://webpack.docschina.org/concepts/targets/#resources">资源</a></li></ul></div></div><div><div class="sidebar-item  "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="15" height="17" fill="#175d96" class="sidebar-item__toggle"><path d="M9.2 4.5l4.5 4.7c.2.2.3.5.3.8s-.1.6-.3.8l-4.5 4.7c-.5.4-1.2.4-1.7 0-.4-.5-.4-1 0-1.6l3.8-3.9-3.8-4c-.4-.4-.4-1 0-1.5.5-.4 1.2-.4 1.7 0z"></path></svg><a class="sidebar-item__title" href="../manifest/index.htm" tppabs="https://webpack.docschina.org/concepts/manifest/">manifest</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="runtime"><a href="../manifest/index.htm#runtime" tppabs="https://webpack.docschina.org/concepts/manifest/#runtime">runtime</a></li><li class="sidebar-item__anchor" title="manifest"><a href="../manifest/index.htm#manifest" tppabs="https://webpack.docschina.org/concepts/manifest/#manifest">manifest</a></li><li class="sidebar-item__anchor" title="问题"><a href="../manifest/index.htm#the-problem" tppabs="https://webpack.docschina.org/concepts/manifest/#the-problem">问题</a></li></ul></div></div><div><div class="sidebar-item  "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="15" height="17" fill="#175d96" class="sidebar-item__toggle"><path d="M9.2 4.5l4.5 4.7c.2.2.3.5.3.8s-.1.6-.3.8l-4.5 4.7c-.5.4-1.2.4-1.7 0-.4-.5-.4-1 0-1.6l3.8-3.9-3.8-4c-.4-.4-.4-1 0-1.5.5-.4 1.2-.4 1.7 0z"></path></svg><a class="sidebar-item__title" href="../hot-module-replacement/index.htm" tppabs="https://webpack.docschina.org/concepts/hot-module-replacement/">模块热替换(hot module replacement)</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="这一切是如何运行的？"><a href="../hot-module-replacement/index.htm#how-it-works" tppabs="https://webpack.docschina.org/concepts/hot-module-replacement/#how-it-works">这一切是如何运行的？</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="在应用程序中"><a href="../hot-module-replacement/index.htm#in-the-application" tppabs="https://webpack.docschina.org/concepts/hot-module-replacement/#in-the-application">在应用程序中</a></li><li class="sidebar-item__anchor" title="在 compiler 中"><a href="../hot-module-replacement/index.htm#in-the-compiler" tppabs="https://webpack.docschina.org/concepts/hot-module-replacement/#in-the-compiler">在 compiler 中</a></li><li class="sidebar-item__anchor" title="在模块中"><a href="../hot-module-replacement/index.htm#in-a-module" tppabs="https://webpack.docschina.org/concepts/hot-module-replacement/#in-a-module">在模块中</a></li><li class="sidebar-item__anchor" title="在 runtime 中"><a href="../hot-module-replacement/index.htm#in-the-runtime" tppabs="https://webpack.docschina.org/concepts/hot-module-replacement/#in-the-runtime">在 runtime 中</a></li></ul></li><li class="sidebar-item__anchor" title="起步"><a href="../hot-module-replacement/index.htm#get-started" tppabs="https://webpack.docschina.org/concepts/hot-module-replacement/#get-started">起步</a></li></ul></div></div><div><div class="sidebar-item  "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="15" height="17" fill="#175d96" class="sidebar-item__toggle"><path d="M9.2 4.5l4.5 4.7c.2.2.3.5.3.8s-.1.6-.3.8l-4.5 4.7c-.5.4-1.2.4-1.7 0-.4-.5-.4-1 0-1.6l3.8-3.9-3.8-4c-.4-.4-.4-1 0-1.5.5-.4 1.2-.4 1.7 0z"></path></svg><a class="sidebar-item__title" href="../why-webpack/index.htm" tppabs="https://webpack.docschina.org/concepts/why-webpack/">为什么选择 webpack</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="立即调用函数表达式(IIFE) - Immediately invoked function expressions"><a href="../why-webpack/index.htm#iifes---immediately-invoked-function-expressions" tppabs="https://webpack.docschina.org/concepts/why-webpack/#iifes---immediately-invoked-function-expressions">立即调用函数表达式(IIFE) - Immediately invoked function expressions</a></li><li class="sidebar-item__anchor" title="感谢 Node.js，JavaScript 模块诞生了"><a href="../why-webpack/index.htm#birth-of-javascript-modules-happened-thanks-to-nodejs" tppabs="https://webpack.docschina.org/concepts/why-webpack/#birth-of-javascript-modules-happened-thanks-to-nodejs">感谢 Node.js，JavaScript 模块诞生了</a></li><li class="sidebar-item__anchor" title="npm + Node.js + modules - 大规模分发模块"><a href="../why-webpack/index.htm#npm--nodejs--modules----mass-distribution" tppabs="https://webpack.docschina.org/concepts/why-webpack/#npm--nodejs--modules----mass-distribution">npm + Node.js + modules - 大规模分发模块</a></li><li class="sidebar-item__anchor" title="ESM - ECMAScript 模块"><a href="../why-webpack/index.htm#esm---ecmascript-modules" tppabs="https://webpack.docschina.org/concepts/why-webpack/#esm---ecmascript-modules">ESM - ECMAScript 模块</a></li><li class="sidebar-item__anchor" title="依赖自动收集"><a href="../why-webpack/index.htm#automatic-dependency-collection" tppabs="https://webpack.docschina.org/concepts/why-webpack/#automatic-dependency-collection">依赖自动收集</a></li><li class="sidebar-item__anchor" title="看起来都不是很好……"><a href="../why-webpack/index.htm#wouldnt-it-be-nice" tppabs="https://webpack.docschina.org/concepts/why-webpack/#wouldnt-it-be-nice">看起来都不是很好……</a></li></ul></div></div><div><div class="sidebar-item  "><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="15" height="17" fill="#175d96" class="sidebar-item__toggle"><path d="M9.2 4.5l4.5 4.7c.2.2.3.5.3.8s-.1.6-.3.8l-4.5 4.7c-.5.4-1.2.4-1.7 0-.4-.5-.4-1 0-1.6l3.8-3.9-3.8-4c-.4-.4-.4-1 0-1.5.5-.4 1.2-.4 1.7 0z"></path></svg><a class="sidebar-item__title" href="../under-the-hood/index.htm" tppabs="https://webpack.docschina.org/concepts/under-the-hood/">揭示内部原理</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="主要部分"><a href="../under-the-hood/index.htm#the-main-parts" tppabs="https://webpack.docschina.org/concepts/under-the-hood/#the-main-parts">主要部分</a></li><li class="sidebar-item__anchor" title="chunk"><a href="../under-the-hood/index.htm#chunks" tppabs="https://webpack.docschina.org/concepts/under-the-hood/#chunks">chunk</a></li><li class="sidebar-item__anchor" title="output(输出)"><a href="../under-the-hood/index.htm#output" tppabs="https://webpack.docschina.org/concepts/under-the-hood/#output">output(输出)</a></li></ul></div></div><div class="sidebar__docs-version">You are reading webpack <!-- -->5<!-- --> documentation. Change here to:<ul><li><a rel="nofollow" href="javascript:if(confirm('https://v4.webpack.docschina.org/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://v4.webpack.docschina.org/'" tppabs="https://v4.webpack.docschina.org/">webpack <!-- -->4<!-- --> documentation</a></li></ul></div></div></nav><section class="page"><div class="page-links"><a class="page-links__link" href="javascript:if(confirm('https://github.com/docschina/webpack.js.org/edit/cn/src/content/concepts/printable.md  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/docschina/webpack.js.org/edit/cn/src/content/concepts/printable.md'" tppabs="https://github.com/docschina/webpack.js.org/edit/cn/src/content/concepts/printable.md">编辑此页<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" class="page-links__icon" width="12" fill="#1a6bac"><path d="M17.6 2.4C16 1 15 1.2 15 1.2l-6 6L2.2 14l-1 4.8 4.8-1 6.7-6.8 6-6s.3-1.1-1.1-2.6zm-12 14.8l-1.5.4-.7-1-1-.7.4-1.6.5-.4s.8 0 1.8 1 1 1.8 1 1.8l-.4.5z"></path></svg></a><span class="page-links__gap">|</span><button class="page-links__link page-links__print as-link" title="Print this page">打印文档<img src="../../icon-print.42ad40feec51e6f5f553.svg" tppabs="https://webpack.docschina.org/icon-print.42ad40feec51e6f5f553.svg" alt=""/></button></div><div class="markdown"><h1>Printable</h1><div><h1 id="概念">概念<a href="#%E6%A6%82%E5%BF%B5" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h1> <p>本质上，<strong>webpack</strong> 是一个用于现代 JavaScript 应用程序的_静态模块打包工具_。当 webpack 处理应用程序时，它会在内部构建一个 <a href="../dependency-graph/index.htm" tppabs="https://webpack.docschina.org/concepts/dependency-graph/">依赖图(dependency graph)</a>，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 <em>bundle</em>。</p> <blockquote class="tip"> <p>可以在 <a href="../modules.htm" tppabs="https://webpack.docschina.org/concepts/modules">这里</a> 了解更多关于 JavaScript 模块和 webpack 模块的信息。</p> </blockquote> <p>从 v4.0.0 开始，__webpack 可以不用再引入一个配置文件__来打包项目，然而，它仍然有着 <a href="../../configuration.htm" tppabs="https://webpack.docschina.org/configuration">高度可配置性</a>，可以很好满足你的需求。</p> <p>在开始前你需要先理解一些__核心概念__：</p> <ul> <li><a href="#entry">入口(entry)</a></li> <li><a href="#output">输出(output)</a></li> <li><a href="#loaders">loader</a></li> <li><a href="#plugins">插件(plugin)</a></li> <li><a href="#mode">模式(mode)</a></li> <li><a href="#browser-compatibility">浏览器兼容性(browser compatibility)</a></li> <li><a href="#environment">环境(environment)</a></li> </ul> <p>本文档旨在给出这些概念的__高度__概述，同时提供具体概念的详尽相关用例的链接。</p> <p>为了更好地理解模块打包工具背后的理念，以及在底层它们是如何运作的，请参考以下资源：</p> <ul> <li><a href="javascript:if(confirm('https://www.youtube.com/watch?v=UNMkLHzofQI  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://www.youtube.com/watch?v=UNMkLHzofQI'" tppabs="https://www.youtube.com/watch?v=UNMkLHzofQI">手动打包一个应用程序</a></li> <li><a href="javascript:if(confirm('https://www.youtube.com/watch?v=Gc9-7PBqOC8  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://www.youtube.com/watch?v=Gc9-7PBqOC8'" tppabs="https://www.youtube.com/watch?v=Gc9-7PBqOC8">实时创建一个简单打包工具</a></li> <li><a href="javascript:if(confirm('https://github.com/ronami/minipack  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/ronami/minipack'" tppabs="https://github.com/ronami/minipack">一个简单打包工具的详细说明</a></li> </ul> <h2 id="entry">入口(entry) <a href="#entry" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>__入口起点(entry point)__指示 webpack 应该使用哪个模块，来作为构建其内部 <a href="../dependency-graph/index.htm" tppabs="https://webpack.docschina.org/concepts/dependency-graph/">依赖图(dependency graph)</a> 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p> <p>默认值是 <code>./src/index.js</code>，但你可以通过在 <a href="../../configuration.htm" tppabs="https://webpack.docschina.org/configuration">webpack configuration</a> 中配置 <code>entry</code> 属性，来指定一个（或多个）不同的入口起点。例如：</p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./path/to/my/entry/file.js'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <blockquote class="tip"> <p>在 <a href="../entry-points.htm" tppabs="https://webpack.docschina.org/concepts/entry-points">入口起点</a> 章节可以了解更多信息。</p> </blockquote> <h2 id="output">输出(output) <a href="#output" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p><strong>output</strong> 属性告诉 webpack 在哪里输出它所创建的 <em>bundle</em>，以及如何命名这些文件。主要输出文件的默认值是 <code>./dist/main.js</code>，其他生成文件默认放置在 <code>./dist</code> 文件夹中。</p> <p>你可以通过在配置中指定一个 <code>output</code> 字段，来配置这些处理过程：</p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./path/to/my/entry/file.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    path<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    filename<span class="token operator">:</span> <span class="token string">'my-first-webpack.bundle.js'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p>在上面的示例中，我们通过 <code>output.filename</code> 和 <code>output.path</code> 属性，来告诉 webpack bundle 的名称，以及我们想要 bundle 生成(emit)到哪里。可能你想要了解在代码最上面导入的 path 模块是什么，它是一个 <a href="javascript:if(confirm('https://nodejs.org/api/modules.html  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://nodejs.org/api/modules.html'" tppabs="https://nodejs.org/api/modules.html">Node.js 核心模块</a>，用于操作文件路径。</p> <blockquote class="tip"> <p><code>output</code> 属性还有 <a href="../../configuration/output.htm" tppabs="https://webpack.docschina.org/configuration/output">更多可配置的特性</a>，如果你想要了解更多关于 <code>output</code> 属性的概念，可以通过阅读 <a href="../output.htm" tppabs="https://webpack.docschina.org/concepts/output">输出章节</a> 来了解更多。</p> </blockquote> <h2 id="loaders">loader <a href="#loaders" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。<strong>loader</strong> 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 <a href="../modules.htm" tppabs="https://webpack.docschina.org/concepts/modules">模块</a>，以供应用程序使用，以及被添加到依赖图中。</p> <blockquote class="warning"> <p>注意，loader 能够 <code>import</code> 导入任何类型的模块（例如 <code>.css</code> 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是很有必要的，因为这可以使开发人员创建出更准确的依赖关系图。</p> </blockquote> <p>在更高层面，在 webpack 的配置中，<strong>loader</strong> 有两个属性：</p> <ol> <li><code>test</code> 属性，识别出哪些文件会被转换。</li> <li><code>use</code> 属性，定义出在进行转换时，应该使用哪个 loader。</li> </ol> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'my-first-webpack.bundle.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span> test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.txt$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> use<span class="token operator">:</span> <span class="token string">'raw-loader'</span> <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p>以上配置中，对一个单独的 module 对象定义了 <code>rules</code> 属性，里面包含两个必须属性：<code>test</code> 和 <code>use</code>。这告诉 webpack 编译器(compiler) 如下信息：</p> <blockquote> <p>“嘿，webpack 编译器，当你碰到「在 <code>require()</code>/<code>import</code> 语句中被解析为 '.txt' 的路径」时，在你对它打包之前，先 <strong>use(使用)</strong> <code>raw-loader</code> 转换一下。”</p> </blockquote> <blockquote class="warning"> <p>重要的是要记住，在 webpack 配置中定义 rules 时，要定义在 <code>module.rules</code> 而不是 <code>rules</code> 中。为了使你便于理解，如果没有按照正确方式去做，webpack 会给出警告。</p> </blockquote> <blockquote class="warning"> <p>请记住，使用正则表达式匹配文件时，你不要为它添加引号。也就是说，<code>/\.txt$/</code> 与 <code>'/\.txt$/'</code> 或 <code>"/\.txt$/"</code> 不一样。前者指示 webpack 匹配任何以 .txt 结尾的文件，后者指示 webpack 匹配具有绝对路径 '.txt' 的单个文件; 这可能不符合你的意图。</p> </blockquote> <p>在使用 loader 时，可以阅读 <a href="../loaders.htm" tppabs="https://webpack.docschina.org/concepts/loaders">loader 章节</a> 查看更深入的自定义配置。</p> <h2 id="plugins">插件(plugin) <a href="#plugins" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。</p> <blockquote class="tip"> <p>查看 <a href="../../api/plugins.htm" tppabs="https://webpack.docschina.org/api/plugins">插件接口(plugin interface)</a>，学习如何使用它来扩展 webpack 能力。</p> </blockquote> <p>想要使用一个插件，你只需要 <code>require()</code> 它，然后把它添加到 <code>plugins</code> 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 <code>new</code> 操作符来创建一个插件实例。</p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-javascript"><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过 npm 安装</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用于访问内置插件</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span> test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.txt$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> use<span class="token operator">:</span> <span class="token string">'raw-loader'</span> <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>template<span class="token operator">:</span> <span class="token string">'./src/index.html'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p>在上面的示例中，<code>html-webpack-plugin</code> 为应用程序生成一个 HTML 文件，并自动注入所有生成的 bundle。</p> <blockquote class="tip"> <p>webpack 提供许多开箱可用的插件！查阅 <a href="../../plugins.htm" tppabs="https://webpack.docschina.org/plugins">插件列表</a> 获取更多。</p> </blockquote> <p>在 webpack 配置中使用插件是简单直接的。然而，也有很多值得我们进一步探讨的用例。<a href="../plugins.htm" tppabs="https://webpack.docschina.org/concepts/plugins">查看这里了解更多</a>。</p> <h2 id="mode">模式(mode) <a href="#mode" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>通过选择 <code>development</code>, <code>production</code> 或 <code>none</code> 之中的一个，来设置 <code>mode</code> 参数，你可以启用 webpack 内置在相应环境下的优化。其默认值为 <code>production</code>。</p> <pre><code class="hljs language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  mode<span class="token operator">:</span> <span class="token string">'production'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p>想要了解更多，请查阅 <a href="../../configuration/mode.htm" tppabs="https://webpack.docschina.org/configuration/mode">mode 配置</a>，这里有具体每个值相应的优化行为。</p> <h2 id="browser-compatibility">浏览器兼容性(browser compatibility) <a href="#browser-compatibility" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>webpack 支持所有符合 <a href="javascript:if(confirm('https://kangax.github.io/compat-table/es5/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://kangax.github.io/compat-table/es5/'" tppabs="https://kangax.github.io/compat-table/es5/">ES5 标准</a> 的浏览器（不支持 IE8 及以下版本）。webpack 的 <code>import()</code> 和 <code>require.ensure()</code> 需要 <code>Promise</code>。如果你想要支持旧版本浏览器，在使用这些表达式之前，还需要 <a href="../../guides/shimming/index.htm" tppabs="https://webpack.docschina.org/guides/shimming/">提前加载 polyfill</a>。</p> <h2 id="environment">环境(environment) <a href="#environment" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>webpack 5 运行于 Node.js v10.13.0+ 的版本。</p> <h1 id="入口起点entry-points">入口起点(entry points)<a href="#%E5%85%A5%E5%8F%A3%E8%B5%B7%E7%82%B9entry-points" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h1> <p>正如我们在 <a href="../../guides/getting-started/index.htm#using-a-configuration" tppabs="https://webpack.docschina.org/guides/getting-started/#using-a-configuration">起步</a> 中提到的，在 webpack 配置中有多种方式定义 <code>entry</code> 属性。除了解释为什么它可能非常有用，我们还将向你展示__如何去__配置 <code>entry</code> 属性。</p> <h2 id="single-entry-shorthand-syntax">单个入口（简写）语法 <a href="#single-entry-shorthand-syntax" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>用法：<code>entry: string | [string]</code></p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./path/to/my/entry/file.js'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p><code>entry</code> 属性的单个入口语法，参考下面的简写：</p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token punctuation">{</span>
    main<span class="token operator">:</span> <span class="token string">'./path/to/my/entry/file.js'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p>我们也可以将一个文件路径数组传递给 <code>entry</code> 属性，这将创建一个所谓的 <strong>"multi-main entry"</strong>。在你想要一次注入多个依赖文件，并且将它们的依赖关系绘制在一个 "chunk" 中时，这种方式就很有用。</p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token punctuation">[</span> 
    <span class="token string">'./src/file_1.js'</span><span class="token punctuation">,</span>
    <span class="token string">'./src/file_2.js'</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p>当你希望通过一个入口（例如一个库）为应用程序或工具快速设置 webpack 配置时，单一入口的语法方式是不错的选择。然而，使用这种语法方式来扩展或调整配置的灵活性不大。</p> <h2 id="object-syntax">对象语法 <a href="#object-syntax" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>用法：<code>entry: { &#x3C;entryChunkName> string | [string] } | {}</code></p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token punctuation">{</span>
    app<span class="token operator">:</span> <span class="token string">'./src/app.js'</span><span class="token punctuation">,</span>
    adminApp<span class="token operator">:</span> <span class="token string">'./src/adminApp.js'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p>对象语法会比较繁琐。然而，这是应用程序中定义入口的最可扩展的方式。</p> <blockquote class="tip"> <p>__“webpack 配置的可扩展”__是指，这些配置可以重复使用，并且可以与其他配置组合使用。这是一种流行的技术，用于将关注点从环境(environment)、构建目标(build target)、运行时(runtime)中分离。然后使用专门的工具（如 <a href="javascript:if(confirm('https://github.com/survivejs/webpack-merge  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/survivejs/webpack-merge'" tppabs="https://github.com/survivejs/webpack-merge">webpack-merge</a>）将它们合并起来。</p> </blockquote> <blockquote class="tip"> <p>当你通过插件生成入口时，你可以传递空对象 <code>{}</code> 给 <code>entry</code>。</p> </blockquote> <h2 id="scenarios">常见场景 <a href="#scenarios" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>以下列出一些入口配置和它们的实际用例：</p> <h3 id="separate-app-and-vendor-entries">分离 app(应用程序) 和 vendor(第三方库) 入口 <a href="#separate-app-and-vendor-entries" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token punctuation">{</span>
    main<span class="token operator">:</span> <span class="token string">'./src/app.js'</span><span class="token punctuation">,</span>
    vendor<span class="token operator">:</span> <span class="token string">'./src/vendor.js'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p><strong>webpack.prod.js</strong></p> <pre><code class="hljs language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'[name].[contenthash].bundle.js'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p><strong>webpack.dev.js</strong></p> <pre><code class="hljs language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'[name].bundle.js'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p>__这是什么？__这是告诉 webpack 我们想要配置 2 个单独的入口点（例如上面的示例）。</p> <p>__为什么？__这样你就可以在 <code>vendor.js</code> 中存入未做修改的必要 library 或文件（例如 Bootstrap, jQuery, 图片等），然后将它们打包在一起成为单独的 chunk。内容哈希保持不变，这使浏览器可以独立地缓存它们，从而减少了加载时间。</p> <blockquote class="tip"> <p>在 webpack &#x3C; 4 的版本中，通常将 vendor 作为一个单独的入口起点添加到 entry 选项中，以将其编译为一个单独的文件（与 <code>CommonsChunkPlugin</code> 结合使用）。<br><br>而在 webpack 4 中不鼓励这样做。而是使用 <a href="../../configuration/optimization/index.htm#optimizationsplitchunks" tppabs="https://webpack.docschina.org/configuration/optimization/#optimizationsplitchunks"><code>optimization.splitChunks</code></a> 选项，将 vendor 和 app(应用程序) 模块分开，并为其创建一个单独的文件。<strong>不要</strong> 为 vendor 或其他不是执行起点创建 entry。</p> </blockquote> <h3 id="multi-page-application">多页面应用程序 <a href="#multi-page-application" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token punctuation">{</span>
    pageOne<span class="token operator">:</span> <span class="token string">'./src/pageOne/index.js'</span><span class="token punctuation">,</span>
    pageTwo<span class="token operator">:</span> <span class="token string">'./src/pageTwo/index.js'</span><span class="token punctuation">,</span>
    pageThree<span class="token operator">:</span> <span class="token string">'./src/pageThree/index.js'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p>__这是什么？__我们告诉 webpack 需要三个独立分离的依赖图（如上面的示例）。</p> <p>__为什么？__在多页面应用程序中，server 会拉取一个新的 HTML 文档给你的客户端。页面重新加载此新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事，例如使用 <a href="../../configuration/optimization/index.htm#optimizationsplitchunks" tppabs="https://webpack.docschina.org/configuration/optimization/#optimizationsplitchunks"><code>optimization.splitChunks</code></a> 为页面间共享的应用程序代码创建 bundle。由于入口起点数量的增多，多页应用能够复用多个入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。</p> <blockquote class="tip"> <p>根据经验：每个 HTML 文档只使用一个入口起点。具体原因请参阅<a href="javascript:if(confirm('https://bundlers.tooling.report/code-splitting/multi-entry/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://bundlers.tooling.report/code-splitting/multi-entry/#webpack'" tppabs="https://bundlers.tooling.report/code-splitting/multi-entry/#webpack">此 issue</a>。</p> </blockquote> <h1 id="输出output">输出(output)<a href="#%E8%BE%93%E5%87%BAoutput" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h1> <p>可以通过配置 <code>output</code> 选项，告知 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个 <code>entry</code> 起点，但只能指定一个 <code>output</code> 配置。</p> <h2 id="usage">用法 <a href="#usage" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>在 webpack 配置中，<code>output</code> 属性的最低要求是，将它的值设置为一个对象，然后为将输出文件的文件名配置为一个 <a href="../../configuration/output/index.htm#outputfilename" tppabs="https://webpack.docschina.org/configuration/output/#outputfilename"><code>output.filename</code></a>：</p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p>此配置将一个单独的 <code>bundle.js</code> 文件输出到 <code>dist</code> 目录中。</p> <h2 id="multiple-entry-points">多个入口起点 <a href="#multiple-entry-points" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>如果配置中创建出多于一个 "chunk"（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用 <a href="../../configuration/output.htm#output-filename" tppabs="https://webpack.docschina.org/configuration/output#output-filename">占位符(substitutions)</a> 来确保每个文件具有唯一的名称。</p> <pre><code class="hljs language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token punctuation">{</span>
    app<span class="token operator">:</span> <span class="token string">'./src/app.js'</span><span class="token punctuation">,</span>
    search<span class="token operator">:</span> <span class="token string">'./src/search.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'[name].js'</span><span class="token punctuation">,</span>
    path<span class="token operator">:</span> __dirname <span class="token operator">+</span> <span class="token string">'/dist'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 写入到硬盘：./dist/app.js, ./dist/search.js</span></code></pre> <h2 id="advanced">高级进阶 <a href="#advanced" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>以下是对资源使用 CDN 和 hash 的复杂示例：</p> <p><strong>config.js</strong></p> <pre><code class="hljs language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    path<span class="token operator">:</span> <span class="token string">'/home/proj/cdn/assets/[fullhash]'</span><span class="token punctuation">,</span>
    publicPath<span class="token operator">:</span> <span class="token string">'https://cdn.example.com/assets/[fullhash]/'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p>如果在编译时，不知道最终输出文件的 <code>publicPath</code> 是什么地址，则可以将其留空，并且在运行时通过入口起点文件中的 <code>__webpack_public_path__</code> 动态设置。</p> <pre><code class="hljs language-javascript">__webpack_public_path__ <span class="token operator">=</span> myRuntimePublicPath<span class="token punctuation">;</span>

<span class="token comment">// 应用程序入口的其余部分</span></code></pre> <h1 id="loader">loader<a href="#loader" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h1> <p>loader 用于对模块的源代码进行转换。loader 可以使你在 <code>import</code> 或 "load(加载)" 模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的得力方式。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript 或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 <code>import</code> CSS文件！</p> <h2 id="example">示例 <a href="#example" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>例如，你可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader：</p> <pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev css-loader ts-loader</code></pre> <p>然后指示 webpack 对每个 <code>.css</code> 使用 <a href="../../loaders/css-loader.htm" tppabs="https://webpack.docschina.org/loaders/css-loader"><code>css-loader</code></a>，以及对所有 <code>.ts</code> 文件使用 <a href="javascript:if(confirm('https://github.com/TypeStrong/ts-loader  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/TypeStrong/ts-loader'" tppabs="https://github.com/TypeStrong/ts-loader"><code>ts-loader</code></a>：</p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span> test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> use<span class="token operator">:</span> <span class="token string">'css-loader'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span> test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.ts$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> use<span class="token operator">:</span> <span class="token string">'ts-loader'</span> <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <h2 id="using-loaders">使用 loader <a href="#using-loaders" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>在你的应用程序中，有三种使用 loader 的方式：</p> <ul> <li><a href="#configuration">配置方式</a>（推荐）：在 <strong>webpack.config.js</strong> 文件中指定 loader。</li> <li><a href="#inline">内联方式</a>：在每个 <code>import</code> 语句中显式指定 loader。</li> <li><a href="#cli">CLI 方式</a>：在 shell 命令中指定它们。</li> </ul> <h3 id="configuration">配置方式 <a href="#configuration" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p><a href="../../configuration/module/index.htm#modulerules" tppabs="https://webpack.docschina.org/configuration/module/#modulerules"><code>module.rules</code></a> 允许你在 webpack 配置中指定多个 loader。 这种方式是展示 loader 的一种简明方式，并且有助于使代码变得简洁和易于维护。同时让你对各个 loader 有个全局概览：</p> <p>loader 从右到左（或从下到上）地取值(evaluate)/执行(execute)。在下面的示例中，从 sass-loader 开始执行，然后继续执行 css-loader，最后以 style-loader 为结束。查看 <a href="../loaders/index.htm#loader-features" tppabs="https://webpack.docschina.org/concepts/loaders/#loader-features">loader 功能</a> 章节，了解有关 loader 顺序的更多信息。</p> <pre><code class="hljs language-js-with-links">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.css$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
        use<span class="token operator">:</span> <span class="token punctuation">[</span>
          <span class="token comment">// [style-loader](/loaders/style-loader)</span>
          <span class="token punctuation">{</span> loader<span class="token operator">:</span> <span class="token string">'style-loader'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token comment">// [css-loader](/loaders/css-loader)</span>
          <span class="token punctuation">{</span>
            loader<span class="token operator">:</span> <span class="token string">'css-loader'</span><span class="token punctuation">,</span>
            options<span class="token operator">:</span> <span class="token punctuation">{</span>
              modules<span class="token operator">:</span> <span class="token boolean">true</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token comment">// [sass-loader](/loaders/sass-loader)</span>
          <span class="token punctuation">{</span> loader<span class="token operator">:</span> <span class="token string">'sass-loader'</span> <span class="token punctuation">}</span>
        <span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <h3 id="inline">内联方式 <a href="#inline" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p>可以在 <code>import</code> 语句或任何 <a href="../../api/module-methods.htm" tppabs="https://webpack.docschina.org/api/module-methods">与 "import" 方法同等的引用方式</a> 中指定 loader。使用 <code>!</code> 将资源中的 loader 分开。每个部分都会相对于当前目录解析。</p> <pre><code class="hljs language-js"><span class="token keyword">import</span> Styles <span class="token keyword">from</span> <span class="token string">'style-loader!css-loader?modules!./styles.css'</span><span class="token punctuation">;</span></code></pre> <p>通过为内联 <code>import</code> 语句添加前缀，可以覆盖 <a href="../../configuration.htm" tppabs="https://webpack.docschina.org/configuration">配置</a> 中的所有 loader, preLoader 和 postLoader：</p> <ul> <li>使用 <code>!</code> 前缀，将禁用所有已配置的 normal loader(普通 loader)</li> </ul> <pre><code class="hljs language-js"><span class="token keyword">import</span> Styles <span class="token keyword">from</span> <span class="token string">'!style-loader!css-loader?modules!./styles.css'</span><span class="token punctuation">;</span></code></pre> <ul> <li>使用 <code>!!</code> 前缀，将禁用所有已配置的 loader（preLoader, loader, postLoader）</li> </ul> <pre><code class="hljs language-js"><span class="token keyword">import</span> Styles <span class="token keyword">from</span> <span class="token string">'!!style-loader!css-loader?modules!./styles.css'</span><span class="token punctuation">;</span></code></pre> <ul> <li>使用 <code>-!</code> 前缀，将禁用所有已配置的 preLoader 和 loader，但是不禁用 postLoaders</li> </ul> <pre><code class="hljs language-js"><span class="token keyword">import</span> Styles <span class="token keyword">from</span> <span class="token string">'-!style-loader!css-loader?modules!./styles.css'</span><span class="token punctuation">;</span></code></pre> <p>选项可以传递查询参数，例如 <code>?key=value&#x26;foo=bar</code>，或者一个 JSON 对象，例如 <code>?{"key":"value","foo":"bar"}</code>。</p> <blockquote class="tip"> <p>尽可能使用 <code>module.rules</code>，因为这样可以减少源码中样板文件的代码量，并且可以在出错时，更快地调试和定位 loader 中的问题。</p> </blockquote> <h3 id="cli">CLI 方式 <a href="#cli" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p>还可以通过 CLI 使用 loader：</p> <pre><code class="hljs language-bash">webpack --module-bind pug-loader --module-bind <span class="token string">'css=style-loader!css-loader'</span></code></pre> <p>这会对 <code>.jade</code> 文件使用 <code>pug-loader</code>，以及对 <code>.css</code> 文件使用 <a href="../../loaders/style-loader.htm" tppabs="https://webpack.docschina.org/loaders/style-loader"><code>style-loader</code></a> 和 <a href="../../loaders/css-loader.htm" tppabs="https://webpack.docschina.org/loaders/css-loader"><code>css-loader</code></a>。</p> <h2 id="loader-features">loader 特性 <a href="#loader-features" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <ul> <li>loader 支持链式调用。链中的每个 loader 会将转换应用在已处理过的资源上。一组链式的 loader 将按照相反的顺序执行。链中的第一个 loader 将其结果（也就是应用过转换后的资源）传递给下一个 loader，依此类推。最后，链中的最后一个 loader，返回 webpack 所期望的 JavaScript。</li> <li>loader 可以是同步的，也可以是异步的。</li> <li>loader 运行在 Node.js 中，并且能够执行任何操作。</li> <li>loader 可以通过 <code>options</code> 对象配置（仍然支持使用 <code>query</code> 参数来设置选项，但是这种方式已被废弃）。</li> <li>除了常见的通过 <code>package.json</code> 的 <code>main</code> 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 <code>loader</code> 字段直接引用一个模块。</li> <li>插件(plugin)可以为 loader 带来更多特性。</li> <li>loader 能够产生额外的任意文件。</li> </ul> <p>可以通过 loader 的预处理函数，为 JavaScript 生态系统提供更多能力。用户现在可以更加灵活地引入细粒度逻辑，例如：压缩、打包、语言翻译和 <a href="../../loaders.htm" tppabs="https://webpack.docschina.org/loaders">更多其他特性</a>。</p> <h2 id="resolving-loaders">解析 loader <a href="#resolving-loaders" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>loader 遵循标准 <a href="../module-resolution/index.htm" tppabs="https://webpack.docschina.org/concepts/module-resolution/">模块解析</a> 规则。多数情况下，loader 将从 <a href="../module-resolution/index.htm#module-paths" tppabs="https://webpack.docschina.org/concepts/module-resolution/#module-paths">模块路径</a> 加载（通常是从 <code>npm install</code>, <code>node_modules</code> 进行加载）。</p> <p>我们预期 loader 模块导出为一个函数，并且编写为 Node.js 兼容的 JavaScript。通常使用 npm 进行管理 loader，但是也可以将应用程序中的文件作为自定义 loader。按照约定，loader 通常被命名为 <code>xxx-loader</code>（例如 <code>json-loader</code>）。更多详细信息，请查看 <a href="../../contribute/writing-a-loader/index.htm" tppabs="https://webpack.docschina.org/contribute/writing-a-loader/">编写一个 loader</a>。</p> <h1 id="plugin">plugin<a href="#plugin" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h1> <p>__插件__是 webpack 的 <a href="javascript:if(confirm('https://github.com/webpack/tapable  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/webpack/tapable'" tppabs="https://github.com/webpack/tapable">支柱</a> 功能。webpack 自身也是构建于你在 webpack 配置中用到的__相同的插件系统__之上！</p> <p>插件目的在于解决 <a href="../loaders.htm" tppabs="https://webpack.docschina.org/concepts/loaders">loader</a> 无法实现的__其他事__。</p> <blockquote class="tip"> <p>如果在插件中使用了 <a href="javascript:if(confirm('https://github.com/webpack/webpack-sources  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/webpack/webpack-sources'" tppabs="https://github.com/webpack/webpack-sources"><code>webpack-sources</code></a> 的 package，请使用 <code>require('webpack').sources</code> 替代 <code>require('webpack-sources')</code>，以避免持久缓存的版本冲突。</p> </blockquote> <h2 id="anatomy">剖析 <a href="#anatomy" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>webpack __插件__是一个具有 <a href="javascript:if(confirm('https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply'" tppabs="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>apply</code></a> 方法的 JavaScript 对象。<code>apply</code> 方法会被 webpack compiler 调用，并且在__整个__编译生命周期都可以访问 compiler 对象。</p> <p><strong>ConsoleLogOnBuildWebpackPlugin.js</strong></p> <pre><code class="hljs language-javascript"><span class="token keyword">const</span> pluginName <span class="token operator">=</span> <span class="token string">'ConsoleLogOnBuildWebpackPlugin'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">ConsoleLogOnBuildWebpackPlugin</span> <span class="token punctuation">{</span>
  <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">compiler</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    compiler<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>run<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span>pluginName<span class="token punctuation">,</span> <span class="token parameter">compilation</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'webpack 构建过程开始！'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> ConsoleLogOnBuildWebpackPlugin<span class="token punctuation">;</span></code></pre> <p>compiler hook 的 tap 方法的第一个参数，应该是驼峰式命名的插件名称。建议为此使用一个常量，以便它可以在所有 hook 中重复使用。</p> <h2 id="usage">用法 <a href="#usage" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>由于__插件__可以携带参数/选项，你必须在 webpack 配置中，向 <code>plugins</code> 属性传入一个 <code>new</code> 实例。</p> <p>取决于你的 webpack 用法，对应有多种使用插件的方式。</p> <h3 id="configuration">配置方式 <a href="#configuration" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-javascript"><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'html-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过 npm 安装</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问内置的插件</span>
<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./path/to/my/entry/file.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    filename<span class="token operator">:</span> <span class="token string">'my-first-webpack.bundle.js'</span><span class="token punctuation">,</span>
    path<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  module<span class="token operator">:</span> <span class="token punctuation">{</span>
    rules<span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\.(js|jsx)$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span>
        use<span class="token operator">:</span> <span class="token string">'babel-loader'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>ProgressPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>template<span class="token operator">:</span> <span class="token string">'./src/index.html'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p><code>ProgressPlugin</code> 用于自定义编译过程中的进度报告，<code>HtmlWebpackPlugin</code> 将生成一个 HTML 文件，并在其中使用 <code>script</code> 引入一个名为 <code>my-first-webpack.bundle.js</code> 的 JS 文件。</p> <h3 id="node-api">Node API 方式 <a href="#node-api" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p>在使用 Node API 时，还可以通过配置中的 <code>plugins</code> 属性传入插件。</p> <p><strong>some-node-script.js</strong></p> <pre><code class="hljs language-javascript"><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问 webpack 运行时(runtime)</span>
<span class="token keyword">const</span> configuration <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./webpack.config.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> compiler <span class="token operator">=</span> <span class="token function">webpack</span><span class="token punctuation">(</span>configuration<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>ProgressPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>compiler<span class="token punctuation">)</span><span class="token punctuation">;</span>

compiler<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> stats</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <blockquote class="tip"> <p>你知道吗：以上看到的示例和 <a href="javascript:if(confirm('https://github.com/webpack/webpack/blob/e7087ffeda7fa37dfe2ca70b5593c6e899629a2c/bin/webpack.js  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/webpack/webpack/blob/e7087ffeda7fa37dfe2ca70b5593c6e899629a2c/bin/webpack.js#L290-L292'" tppabs="https://github.com/webpack/webpack/blob/e7087ffeda7fa37dfe2ca70b5593c6e899629a2c/bin/webpack.js#L290-L292">webpack 运行时(runtime)本身</a> 极其类似。<a href="javascript:if(confirm('https://github.com/webpack/webpack  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/webpack/webpack'" tppabs="https://github.com/webpack/webpack">webpack 源码</a> 中隐藏有大量使用示例，你可以将其应用在自己的配置和脚本中。</p> </blockquote> <h1 id="配置（Configuration）">配置（Configuration）<a href="#%E9%85%8D%E7%BD%AE%EF%BC%88Configuration%EF%BC%89" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h1> <p>你可能已经注意到，很少有 webpack 配置看起来完全相同。这是因为 <strong>webpack 的配置文件是 JavaScript 文件，文件内导出了一个 webpack <a href="../../configuration/index.htm" tppabs="https://webpack.docschina.org/configuration/">配置的对象</a>。</strong> webpack 会根据该配置定义的属性进行处理。</p> <p>由于 webpack 遵循 CommonJS 模块规范，因此，你__可以在配置中使用__：</p> <ul> <li>通过 <code>require(...)</code> 引入其他文件</li> <li>通过 <code>require(...)</code> 使用 npm 下载的工具函数</li> <li>使用 JavaScript 控制流表达式，例如 <code>?:</code> 操作符</li> <li>对 value 使用常量或变量赋值</li> <li>编写并执行函数，生成部分配置</li> </ul> <p>请在合适的场景，使用这些功能。</p> <p>虽然技术上可行，<strong>但还是应避免如下操作</strong>：</p> <ul> <li>当使用 webpack CLI 工具时，访问 CLI 参数（应编写自己的 CLI 工具替代，或者<a href="../../configuration/configuration-types/index.htm" tppabs="https://webpack.docschina.org/configuration/configuration-types/">使用 <code>--env</code></a>）</li> <li>导出不确定的结果（两次调用 webpack 应产生相同的输出文件）</li> <li>编写超长的配置（应将配置文件拆分成多个）</li> </ul> <blockquote class="tip"> <p>此文档中得出最重要的结论是，webpack 的配置可以有许多不同的样式和风格。关键在于，为了易于维护和理解这些配置，需要在团队内部保证一致。</p> </blockquote> <p>接下来的示例中，展示了 webpack 配置如何实现既可表达，又可灵活配置，这主要得益于_配置即为代码_：</p> <h2 id="simple-configuration">基本配置 <a href="#simple-configuration" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-javascript"><span class="token keyword">var</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  mode<span class="token operator">:</span> <span class="token string">'development'</span><span class="token punctuation">,</span>
  entry<span class="token operator">:</span> <span class="token string">'./foo.js'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    path<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    filename<span class="token operator">:</span> <span class="token string">'foo.bundle.js'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p><em>查看</em>：<a href="../../configuration/index.htm" tppabs="https://webpack.docschina.org/configuration/">配置章节</a>中所有支持的配置选项。</p> <h2 id="multiple-targets">多个 target <a href="#multiple-targets" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>除了可以将单个配置导出为 object，<a href="../../configuration/configuration-types/index.htm#exporting-a-function" tppabs="https://webpack.docschina.org/configuration/configuration-types/#exporting-a-function">function</a> 或 <a href="../../configuration/configuration-types/index.htm#exporting-a-promise" tppabs="https://webpack.docschina.org/configuration/configuration-types/#exporting-a-promise">Promise</a> 以外，还可以将其导出为多个配置。</p> <p><em>查看</em>：<a href="../../configuration/configuration-types/index.htm#exporting-multiple-configurations" tppabs="https://webpack.docschina.org/configuration/configuration-types/#exporting-multiple-configurations">导出多个配置</a></p> <h2 id="using-other-configuration-languages">使用其它配置语言 <a href="#using-other-configuration-languages" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>webpack 支持由多种编程和数据语言编写的配置文件。</p> <p><em>查看</em>：<a href="../../configuration/configuration-languages/index.htm" tppabs="https://webpack.docschina.org/configuration/configuration-languages/">配置语言</a></p> <h1 id="模块（Modules）">模块（Modules）<a href="#%E6%A8%A1%E5%9D%97%EF%BC%88Modules%EF%BC%89" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h1> <p>在<a href="javascript:if(confirm('https://en.wikipedia.org/wiki/Modular_programming  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://en.wikipedia.org/wiki/Modular_programming'" tppabs="https://en.wikipedia.org/wiki/Modular_programming">模块化编程</a>中，开发者将程序分解为功能离散的 chunk，并称之为 <strong>模块</strong>。</p> <p>每个模块都拥有小于完整程序的体积，使得验证、调试及测试变得轻而易举。 精心编写的 __模块__提供了可靠的抽象和封装界限，使得应用程序中每个模块都具备了条理清晰的设计和明确的目的。</p> <p>Node.js 从一开始就支持模块化编程。 然而，web 的_模块化_正在缓慢支持中。 在 web 界存在多种支持 JavaScript 模块化的工具，这些工具各有优势和限制。 webpack 从这些系统中汲取了经验和教训，并将_模块_的概念应用到项目的任何文件中。</p> <h2 id="what-is-a-webpack-module">何为 webpack 模块 <a href="#what-is-a-webpack-module" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>与 <a href="javascript:if(confirm('https://nodejs.org/api/modules.html  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://nodejs.org/api/modules.html'" tppabs="https://nodejs.org/api/modules.html">Node.js 模块</a>相比，webpack _模块_能以各种方式表达它们的依赖关系。下面是一些示例：</p> <ul> <li><a href="javascript:if(confirm('https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import'" tppabs="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">ES2015 <code>import</code></a> 语句</li> <li><a href="javascript:if(confirm('http://www.commonjs.org/specs/modules/1.0/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://www.commonjs.org/specs/modules/1.0/'" tppabs="http://www.commonjs.org/specs/modules/1.0/">CommonJS</a> <code>require()</code> 语句</li> <li><a href="javascript:if(confirm('https://github.com/amdjs/amdjs-api/blob/master/AMD.md  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/amdjs/amdjs-api/blob/master/AMD.md'" tppabs="https://github.com/amdjs/amdjs-api/blob/master/AMD.md">AMD</a> <code>define</code> 和 <code>require</code> 语句</li> <li>css/sass/less 文件中的 <a href="javascript:if(confirm('https://developer.mozilla.org/en-US/docs/Web/CSS/@import  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://developer.mozilla.org/en-US/docs/Web/CSS/@import'" tppabs="https://developer.mozilla.org/en-US/docs/Web/CSS/@import"><code>@import</code> 语句</a>。</li> <li>stylesheet <code>url(...)</code> 或者 HTML <code>&#x3C;img src=...></code> 文件中的图片链接。</li> </ul> <h2 id="supported-module-types">支持的模块类型 <a href="#supported-module-types" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>webpack 天生支持如下模块类型：</p> <ul> <li><a href="../../guides/ecma-script-modules.htm" tppabs="https://webpack.docschina.org/guides/ecma-script-modules">ECMAScript 模块</a></li> <li>CommonJS 模块</li> <li>AMD 模块</li> <li><a href="../../guides/asset-modules.htm" tppabs="https://webpack.docschina.org/guides/asset-modules">Assets</a></li> <li>WebAssembly 模块</li> </ul> <p>通过 <strong>loader</strong> 可以使 webpack 支持多种语言和预处理器语法编写的模块。<strong>loader</strong> 向 webpack 描述了如何处理非原生<em>模块</em>，并将相关<strong>依赖</strong>引入到你的 <strong>bundles</strong>中。 webpack 社区已经为各种流行的语言和预处理器创建了 <em>loader</em>，其中包括：</p> <ul> <li><a href="javascript:if(confirm('http://coffeescript.org/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://coffeescript.org/'" tppabs="http://coffeescript.org/">CoffeeScript</a></li> <li><a href="javascript:if(confirm('https://www.typescriptlang.org/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://www.typescriptlang.org/'" tppabs="https://www.typescriptlang.org/">TypeScript</a></li> <li><a href="javascript:if(confirm('https://babeljs.io/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://babeljs.io/'" tppabs="https://babeljs.io/">ESNext (Babel)</a></li> <li><a href="javascript:if(confirm('http://sass-lang.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://sass-lang.com/'" tppabs="http://sass-lang.com/">Sass</a></li> <li><a href="javascript:if(confirm('http://lesscss.org/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://lesscss.org/'" tppabs="http://lesscss.org/">Less</a></li> <li><a href="javascript:if(confirm('http://stylus-lang.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='http://stylus-lang.com/'" tppabs="http://stylus-lang.com/">Stylus</a></li> <li><a href="javascript:if(confirm('https://elm-lang.org/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://elm-lang.org/'" tppabs="https://elm-lang.org/">Elm</a></li> </ul> <p>当然还有更多！总得来说，webpack 提供了可定制，强大且丰富的 API，允许在 <strong>任何技术栈</strong> 中使用，同时支持在开发、测试和生产环境的工作流中做到 <strong>无侵入性</strong>。</p> <p>关于 loader 的相关信息，请参考 <a href="../../loaders.htm" tppabs="https://webpack.docschina.org/loaders"><strong>loader 列表</strong></a> 或 <a href="../../api/loaders.htm" tppabs="https://webpack.docschina.org/api/loaders"><strong>自定义 loader</strong></a>。</p> <h1 id="模块解析（Module-Resolution）">模块解析（Module Resolution）<a href="#%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90%EF%BC%88Module-Resolution%EF%BC%89" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h1> <p>resolver 是一个帮助寻找模块绝对路径的库。 一个模块可以作为另一个模块的依赖模块，然后被后者引用，如下：</p> <pre><code class="hljs language-js"><span class="token keyword">import</span> foo <span class="token keyword">from</span> <span class="token string">'path/to/module'</span><span class="token punctuation">;</span>
<span class="token comment">// 或者</span>
<span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path/to/module'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p>所依赖的模块可以是来自应用程序的代码或第三方库。 resolver 帮助 webpack 从每个 <code>require</code>/<code>import</code> 语句中，找到需要引入到 bundle 中的模块代码。 当打包模块时，webpack 使用 <a href="javascript:if(confirm('https://github.com/webpack/enhanced-resolve  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/webpack/enhanced-resolve'" tppabs="https://github.com/webpack/enhanced-resolve">enhanced-resolve</a> 来解析文件路径。</p> <h2 id="resolving-rules-in-webpack">webpack 中的解析规则 <a href="#resolving-rules-in-webpack" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>使用 <code>enhanced-resolve</code>，webpack 能解析三种文件路径：</p> <h3 id="absolute-paths">绝对路径 <a href="#absolute-paths" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <pre><code class="hljs language-js"><span class="token keyword">import</span> <span class="token string">'/home/me/file'</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token string">'C:\\Users\\me\\file'</span><span class="token punctuation">;</span></code></pre> <p>由于已经获得文件的绝对路径，因此不需要再做进一步解析。</p> <h3 id="relative-paths">相对路径 <a href="#relative-paths" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <pre><code class="hljs language-js"><span class="token keyword">import</span> <span class="token string">'../src/file1'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">'./file2'</span><span class="token punctuation">;</span></code></pre> <p>在这种情况下，使用 <code>import</code> 或 <code>require</code> 的资源文件所处的目录，被认为是上下文目录。在 <code>import/require</code> 中给定的相对路径，会拼接此上下文路径，来生成模块的绝对路径。</p> <h3 id="module-paths">模块路径 <a href="#module-paths" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <pre><code class="hljs language-js"><span class="token keyword">import</span> <span class="token string">'module'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">'module/lib/file'</span><span class="token punctuation">;</span></code></pre> <p>在 <a href="../../configuration/resolve/index.htm#resolvemodules" tppabs="https://webpack.docschina.org/configuration/resolve/#resolvemodules"><code>resolve.modules</code></a> 中指定的所有目录检索模块。 你可以通过配置别名的方式来替换初始模块路径，具体请参照 <a href="../../configuration/resolve/index.htm#resolvealias" tppabs="https://webpack.docschina.org/configuration/resolve/#resolvealias"><code>resolve.alias</code></a> 配置选项。</p> <ul> <li>如果 package 中包含 <code>package.json</code> 文件，那么在 <a href="../../configuration/resolve/index.htm#resolveexportsfields" tppabs="https://webpack.docschina.org/configuration/resolve/#resolveexportsfields"><code>resolve.exportsFields</code></a> 配置选项中指定的字段会被依次查找，<code>package.json</code> 中的第一个字段会根据 <a href="../../guides/package-exports/index.htm" tppabs="https://webpack.docschina.org/guides/package-exports/">package 导出指南</a>确定 package 中可用的 export。</li> </ul> <p>一旦根据上述规则解析路径后，resolver 将会检查路径是指向文件还是文件夹。如果路径指向文件：</p> <ul> <li>如果文件具有扩展名，则直接将文件打包。</li> <li>否则，将使用 <a href="../../configuration/resolve/index.htm#resolveextensions" tppabs="https://webpack.docschina.org/configuration/resolve/#resolveextensions"><code>resolve.extensions</code></a> 选项作为文件扩展名来解析，此选项会告诉解析器在解析中能够接受那些扩展名（例如 <code>.js</code>，<code>.jsx</code>）。</li> </ul> <p>如果路径指向一个文件夹，则进行如下步骤寻找具有正确扩展名的文件：</p> <ul> <li>如果文件夹中包含 <code>package.json</code> 文件，则会根据 <a href="../../configuration/resolve/index.htm#resolve-mainfields" tppabs="https://webpack.docschina.org/configuration/resolve/#resolve-mainfields"><code>resolve.mainFields</code></a> 配置中的字段顺序查找，并根据 <code>package.json</code> 中的符合配置要求的第一个字段来确定文件路径。</li> <li>如果不存在 <code>package.json</code> 文件或 <a href="../../configuration/resolve/index.htm#resolvemainfields" tppabs="https://webpack.docschina.org/configuration/resolve/#resolvemainfields"><code>resolve.mainFields</code></a> 没有返回有效路径，则会根据 <a href="../../configuration/resolve/index.htm#resolvemainfiles" tppabs="https://webpack.docschina.org/configuration/resolve/#resolvemainfiles"><code>resolve.mainFiles</code></a> 配置选项中指定的文件名顺序查找，看是否能在 import/require 的目录下匹配到一个存在的文件名。</li> <li>然后使用 <a href="../../configuration/resolve/index.htm#resolveextensions" tppabs="https://webpack.docschina.org/configuration/resolve/#resolveextensions"><code>resolve.extensions</code></a> 选项，以类似的方式解析文件扩展名。</li> </ul> <p>webpack 会根据构建目标，为这些选项提供合理的<a href="../../configuration/resolve.htm" tppabs="https://webpack.docschina.org/configuration/resolve">默认</a>配置。</p> <h2 id="resolving-loaders">解析 loader <a href="#resolving-loaders" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>loader 的解析规则也遵循特定的规范。但是 <a href="../../configuration/resolve/index.htm#resolveloader" tppabs="https://webpack.docschina.org/configuration/resolve/#resolveloader"><code>resolveLoader</code></a> 配置项可以为 loader 设置独立的解析规则。</p> <h2 id="caching">缓存 <a href="#caching" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>每次文件系统访问文件都会被缓存，以便于更快触发对同一文件的多个并行或串行请求。在 <a href="../../configuration/watch/index.htm#watch" tppabs="https://webpack.docschina.org/configuration/watch/#watch">watch 模式</a> 下，只有修改过的文件会被从缓存中移出。如果关闭 watch 模式，则会在每次编译前清理缓存。</p> <p>欲了解更多上述配置信息，请查阅 <a href="../../configuration/resolve.htm" tppabs="https://webpack.docschina.org/configuration/resolve">Resolve API</a>。</p> <h1 id="Module-Federation">Module Federation<a href="#Module-Federation" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h1> <h2 id="motivation">动机 <a href="#motivation" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。</p> <p>这通常被称作微前端，但并不仅限于此。</p> <h2 id="low-level-concepts">底层概念 <a href="#low-level-concepts" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>我们区分本地模块和远程模块。本地模块即为普通模块，是当前构建的一部分。远程模块不属于当前构建，并在运行时从所谓的容器加载。</p> <p>加载远程模块被认为是异步操作。当使用远程模块时，这些异步操作将被放置在远程模块和入口之间的下一个 chunk 的加载操作中。如果没有 chunk 加载操作，就不能使用远程模块。</p> <p>chunk 的加载操作通常是通过调用 <code>import()</code> 实现的，但也支持像 <code>require.ensure</code> 或 <code>require([...])</code> 之类的旧语法。</p> <p>容器是由容器入口创建的，该入口暴露了对特定模块的异步访问。暴露的访问分为两个步骤：</p> <ol> <li>加载模块（异步的）</li> <li>执行模块（同步的）</li> </ol> <p>步骤 1 将在 chunk 加载期间完成。步骤 2 将在与其他（本地和远程）的模块交错执行期间完成。这样一来，执行顺序不受模块从本地转换为远程或从远程转为本地的影响。</p> <p>容器可以嵌套使用，容器可以使用来自其他容器的模块。容器之间也可以循环依赖。</p> <h3 id="overriding">重载（Overriding） <a href="#overriding" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p>容器能够将选定的本地模块标记为“可重载”。容器的使用者能够提供“重载”，即替换容器中的一个“可重载”的模块。当使用者提供重载模块时，容器的所有模块将使用替换模块而非本地模块。当使用者不提供替换模块时，容器的所有模块将使用本地模块。</p> <p>容器管理可重载模块的方式为：当使用者已经重写它们后，就不需要下载了。这通常是通过将它们放在单独的 chunk 中来实现的。</p> <p>另一方面，替换模块的提供者，将只提供异步加载函数。它允许容器仅在需要替换模块时才去加载。提供者管理替换模块的方式为：当容器不请求替换模块时，则无需下载。这通常是通过将它们放在单独的 chunk 中来实现的。</p> <p>"name" 用于标识容器中可重载的模块。</p> <p>重载（Overrides）的提供和容器暴露模块类似，它分为两个步骤:</p> <ol> <li>加载（异步）</li> <li>执行（同步）</li> </ol> <blockquote class="warning"> <p>当嵌套使用时，向容器提供重载将自动覆盖嵌套容器中具有相同 "name" 的模块。</p> </blockquote> <p>必须在容器模块加载之前提供重载。在初始 chunk 中使用的重载只能被不使用 Promise 的同步模块重载。一旦执行，就不可再次被重载。</p> <h2 id="high-level-concepts">高级概念 <a href="#high-level-concepts" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>每个构建都充当一个容器，也可将其他构建作为容器。通过这种方式，每个构建都能够通过从对应容器中加载模块来访问其他容器暴露出来的模块。</p> <p>共享模块是指既可重写的又可作为向嵌套容器提供重写的模块。它们通常指向每个构建中的相同模块，例如相同的库。</p> <p>packageName 选项允许通过设置包名来查找所需的版本。默认情况下，它会自动推断模块请求，当想禁用自动推断时，请将 requiredVersion 设置为 false 。</p> <h2 id="building-blocks">构建块(Building blocks) <a href="#building-blocks" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <h3 id="overridablesplugin-low-level"><code>OverridablesPlugin</code> (底层 API) <a href="#overridablesplugin-low-level" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p>这个插件使得特定模块“可重载”。一个本地 API ( <code>__webpack_override__</code> ) 允许提供重载。</p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-javascript"><span class="token keyword">const</span> OverridablesPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack/lib/container/OverridablesPlugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  plugins<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">OverridablesPlugin</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        <span class="token comment">// 通过 OverridablesPlugin 定义一个可重载的模块</span>
        test1<span class="token operator">:</span> <span class="token string">'./src/test1.js'</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p><strong>src/index.js</strong></p> <pre><code class="hljs language-javascript"><span class="token function">__webpack_override__</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 这里我们重写 test1 模块</span>
  <span class="token function-variable function">test1</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token string">'I will override test1 module under src'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <h3 id="containerplugin-low-level"><code>ContainerPlugin</code> (底层 API) <a href="#containerplugin-low-level" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p>该插件使用指定的公开模块来创建一个额外的容器入口。它还会在内部使用 OverridablesPlugin，并向容器的使用者暴露 <code>override</code> API。</p> <h3 id="containerreferenceplugin-low-level"><code>ContainerReferencePlugin</code> (底层 API) <a href="#containerreferenceplugin-low-level" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p>该插件将特定的引用添加到作为外部资源（externals）的容器中，并允许从这些容器中导入远程模块。它还会调用这些容器的 <code>override</code> API 来为它们提供重载。本地的重载（当构建也是一个容器时，通过 <code>__webpack_override__</code> 或 <code>override</code> API）和指定的重载被提供给所有引用的容器。</p> <h3 id="modulefederationplugin-high-level"><code>ModuleFederationPlugin</code> （高级 API）<a href="#modulefederationplugin-high-level" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p>该插件组合了 <code>ContainerPlugin</code> 和 <code>ContainerReferencePlugin</code>。重载（overrides）和可重载（overridables）被合并到指定共享模块的单个列表中。</p> <h2 id="concept-goals">概念目标 <a href="#concept-goals" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <ul> <li>它既可以暴露，又可以使用 webpack 支持的任何模块类型</li> <li>代码块加载应该并行加载所需的所有内容(web:到服务器的单次往返)</li> <li>从使用者到容器的控制 <ul> <li>重写模块是一种单向操作</li> <li>同级容器不能重写彼此的模块。</li> </ul> </li> <li>概念适用于独立于环境 <ul> <li>可用于 web、Node.js 等</li> </ul> </li> <li>共享中的相对和绝对请求 <ul> <li>会一直提供，即使不使用</li> <li>会将相对路径解析到 <code>config.context</code> </li> <li>默认不会使用 <code>requiredVersion</code> </li> </ul> </li> <li>共享中的模块请求 <ul> <li>只在使用时提供</li> <li>会匹配构建中所有使用的相等模块请求</li> <li>将提供所有匹配模块</li> <li>将从图中这个位置的 package.json 提取 <code>requiredVersion</code> </li> <li>当你有嵌套的 node_modules 时，可以提供和使用多个不同的版本</li> </ul> </li> <li>共享中尾部带有 <code>/</code> 的模块请求将匹配所有具有这个前缀的模块请求</li> </ul> <h2 id="use-cases">用例 <a href="#use-cases" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <h3 id="separate-builds-per-page">每个页面单独构建 <a href="#separate-builds-per-page" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p>单页应用的每个页面都是在单独的构建中从容器暴露出来的。主体应用程序(application shell)也是独立构建，会将所有页面作为远程模块来引用。通过这种方式，可以单独部署每个页面。在更新路由或添加新路由时部署主体应用程序。主体应用程序将常用库定义为共享模块，以避免在页面构建中出现重复。</p> <h3 id="components-library-as-container">将组件库作为容器 <a href="#components-library-as-container" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p>许多应用程序共享一个通用的组件库，可以将其构建成暴露所有组件的容器。每个应用程序使用来自组件库容器的组件。可以单独部署对组件库的更改，而不需要重新部署所有应用程序。应用程序自动使用组件库的最新版本。</p> <h2 id="dynamic-remote-containers">动态远程容器 <a href="#dynamic-remote-containers" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>该容器接口支持 <code>get</code> 和 <code>init</code> 方法。 <code>init</code> 是一个兼容 <code>async</code> 的方法，调用时，只含有一个参数：共享作用域对象(shared scope object)。此对象在远程容器中用作共享作用域，并由 host 提供的模块填充。 可以利用它在运行时动态地将远程容器连接到 host 容器。</p> <p><strong>init.js</strong></p> <pre><code class="hljs language-javascript"><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// 初始化共享作用域（shared scope）用提供的已知此构建和所有远程的模块填充它</span>
  <span class="token keyword">await</span> <span class="token function">__webpack_init_sharing__</span><span class="token punctuation">(</span><span class="token string">'default'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> container <span class="token operator">=</span> window<span class="token punctuation">.</span>someContainer<span class="token punctuation">;</span> <span class="token comment">// 或从其他地方获取容器</span>
  <span class="token comment">// 初始化容器 它可能提供共享模块</span>
  <span class="token keyword">await</span> container<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>__webpack_share_scopes__<span class="token punctuation">.</span>default<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> module <span class="token operator">=</span> <span class="token keyword">await</span> container<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'./module'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p>容器尝试提供共享模块，但是如果共享模块已经被使用，则会发出警告，并忽略所提供的共享模块。容器仍能将其作为降级模块。</p> <p>你可以通过动态加载的方式，提供一个共享模块的不同版本，从而实现 A/B 测试。</p> <blockquote class="tip"> <p>在尝试动态连接远程容器之前，确保已加载容器。</p> </blockquote> <p>例子：</p> <p><strong>init.js</strong></p> <pre><code class="hljs language-javascript"><span class="token keyword">function</span> <span class="token function">loadComponent</span><span class="token punctuation">(</span><span class="token parameter">scope<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// 初始化共享作用域（shared scope）用提供的已知此构建和所有远程的模块填充它</span>
    <span class="token keyword">await</span> <span class="token function">__webpack_init_sharing__</span><span class="token punctuation">(</span><span class="token string">'default'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> container <span class="token operator">=</span> window<span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 或从其他地方获取容器</span>
    <span class="token comment">// 初始化容器 它可能提供共享模块</span>
    <span class="token keyword">await</span> container<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>__webpack_share_scopes__<span class="token punctuation">.</span>default<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> factory <span class="token operator">=</span> <span class="token keyword">await</span> window<span class="token punctuation">[</span>scope<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>module<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> Module <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Module<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">loadComponent</span><span class="token punctuation">(</span><span class="token string">'abtests'</span><span class="token punctuation">,</span> <span class="token string">'test123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p><a href="javascript:if(confirm('https://github.com/module-federation/module-federation-examples/tree/master/advanced-api/dynamic-remotes  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/module-federation/module-federation-examples/tree/master/advanced-api/dynamic-remotes'" tppabs="https://github.com/module-federation/module-federation-examples/tree/master/advanced-api/dynamic-remotes">查看完整实现</a></p> <h2 id="troubleshooting">故障排除 <a href="#troubleshooting" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p><strong><code>Uncaught Error: Shared module is not available for eager consumption</code></strong></p> <p>应用程序正急切地执行一个作为全局主机运行的应用程序。有如下选项可供选择:</p> <p>你可以在模块联邦的高级 API 中将依赖设置为即时依赖，此 API 不会将模块放在异步 chunk 中，而是同步地提供它们。这使得我们在初始块中可以直接使用这些共享模块。但是要注意，由于所有提供的和降级模块是要异步下载的，因此，建议只在应用程序的某个地方提供它，例如 shell。</p> <p>我们强烈建议使用异步边界(asynchronous boundary)。它将把初始化代码分割成更大的块，以避免任何额外的开销，以提高总体性能。</p> <p>例如，你的入口看起来是这样的：</p> <p><strong>index.js</strong></p> <pre><code class="hljs language-javascript"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App'</span><span class="token punctuation">;</span>
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span>App <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p>让我们创建 bootstrap.js 文件，并将入口文件的内容放到里面，然后将 bootstrap 引入到入口文件中:</p> <p><strong>index.js</strong></p> <pre><code class="hljs language-diff"><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> import('./bootstrap');
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> import React from 'react';
</span><span class="token prefix deleted">-</span><span class="token line"> import ReactDOM from 'react-dom';
</span><span class="token prefix deleted">-</span><span class="token line"> import App from './App';
</span><span class="token prefix deleted">-</span><span class="token line"> ReactDOM.render(&#x3C;App />, document.getElementById('root'));</span></span></code></pre> <p><strong>bootstrap.js</strong></p> <pre><code class="hljs language-diff"><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> import React from 'react';
</span><span class="token prefix inserted">+</span><span class="token line"> import ReactDOM from 'react-dom';
</span><span class="token prefix inserted">+</span><span class="token line"> import App from './App';
</span><span class="token prefix inserted">+</span><span class="token line"> ReactDOM.render(&#x3C;App />, document.getElementById('root'));</span></span></code></pre> <p>这种方法有效，但存在局限性或缺点。</p> <p>通过 <code>ModuleFederationPlugin</code> 将依赖的 <code>eager</code> 属性设置为 <code>true</code> </p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-javascript"><span class="token comment">// ...</span>
<span class="token keyword">new</span> <span class="token class-name">ModuleFederationPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  shared<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>deps<span class="token punctuation">,</span>
    react<span class="token operator">:</span> <span class="token punctuation">{</span>
      eager<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p><strong><code>Uncaught Error: Module "./Button" does not exist in container.</code></strong></p> <p>错误提示中可能不会显示 <code>"./Button"</code>，但是信息看起来差不多。这个问题通常会出现在将 webpack beta.16 升级到 webpack beta.17 中。</p> <p>在 ModuleFederationPlugin 里，更改 exposes:</p> <pre><code class="hljs language-diff">new ModuleFederationPlugin({
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> exposes: {
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">   'Button': './src/Button'
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   './Button':'./src/Button'
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> }
</span></span>});</code></pre> <p><strong><code>Uncaught TypeError: fn is not a function</code></strong></p> <p>此处错误可能是丢失了远程容器，请确保在使用前添加它。 如果已为试图使用远程服务器的容器加载了容器，但仍然看到此错误，则需将主机容器的远程容器文件也添加到 HTML 中。</p> <h1 id="依赖图dependency-graph">依赖图(dependency graph)<a href="#%E4%BE%9D%E8%B5%96%E5%9B%BEdependency-graph" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h1> <p>每当一个文件依赖另一个文件时，webpack 都会将文件视为直接存在 <em>依赖关系</em>。这使得 webpack 可以获取非代码资源，如 images 或 web 字体等。并会把它们作为 <em>依赖</em> 提供给应用程序。</p> <p>当 webpack 处理应用程序时，它会根据命令行参数中或配置文件中定义的模块列表开始处理。 从 <a href="../entry-points/index.htm" tppabs="https://webpack.docschina.org/concepts/entry-points/"><em>入口</em></a> 开始，webpack 会递归的构建一个_依赖关系图_，这个依赖图包含着应用程序中所需的每个模块，然后将所有模块打包为少量的 <em>bundle</em> —— 通常只有一个 —— 可由浏览器加载。</p> <blockquote class="tip"> <p>对于 <em>HTTP/1.1</em> 的应用程序来说，由 webpack 构建的 bundle 非常强大。当浏览器发起请求时，它能最大程度的减少应用的等待时间。而对于 <em>HTTP/2</em> 来说，你还可以使用<a href="../../guides/code-splitting/index.htm" tppabs="https://webpack.docschina.org/guides/code-splitting/">代码分割</a>进行进一步优化。</p> </blockquote> <h1 id="target">target<a href="#target" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h1> <p>由于 JavaScript 即可以编写服务端代码也可以编写浏览器代码，所以 webpack 提供了多种部署 <em>target</em>，你可以在 webpack 的<a href="../../configuration.htm" tppabs="https://webpack.docschina.org/configuration">配置选项</a>中进行设置。</p> <blockquote class="warning"> <p>webpack 的 <code>target</code> 属性，不要和 <code>output.libraryTarget</code> 属性混淆。有关 <code>output</code> 属性的更多信息，请参阅 <a href="../output/index.htm" tppabs="https://webpack.docschina.org/concepts/output/">output 指南</a></p> </blockquote> <h2 id="usage">用法 <a href="#usage" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>想设置 <code>target</code> 属性，只需在 webpack 配置中设置 target 字段：</p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  target<span class="token operator">:</span> <span class="token string">'node'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p>在上述示例中，target 设置为 <code>node</code>，webpack 将在类 Node.js 环境编译代码。(使用 Node.js 的 <code>require</code> 加载 chunk，而不加载任何内置模块，如 <code>fs</code> 或 <code>path</code>)。</p> <p>每个 <em>target</em> 都包含各种 deployment（部署）/environment（环境）特定的附加项，以满足其需求。具体请参阅 <a href="../../configuration/target/index.htm" tppabs="https://webpack.docschina.org/configuration/target/">target 可用值</a>。</p> <blockquote class="todo"> <p>后续会进一步扩展受欢迎的 target。</p> </blockquote> <h2 id="multiple-targets">多 target <a href="#multiple-targets" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>虽然 webpack <strong>不支持</strong> 向 <code>target</code> 属性传入多个字符串，但是可以通过设置两个独立配置，来构建对 library 进行同构：</p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> serverConfig <span class="token operator">=</span> <span class="token punctuation">{</span>
  target<span class="token operator">:</span> <span class="token string">'node'</span><span class="token punctuation">,</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    path<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    filename<span class="token operator">:</span> <span class="token string">'lib.node.js'</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//…</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> clientConfig <span class="token operator">=</span> <span class="token punctuation">{</span>
  target<span class="token operator">:</span> <span class="token string">'web'</span><span class="token punctuation">,</span> <span class="token comment">// &#x3C;=== 默认为 'web'，可省略</span>
  output<span class="token operator">:</span> <span class="token punctuation">{</span>
    path<span class="token operator">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    filename<span class="token operator">:</span> <span class="token string">'lib.js'</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//…</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">[</span> serverConfig<span class="token punctuation">,</span> clientConfig <span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre> <p>上述示例中，将会在 <code>dist</code> 文件夹下创建 <code>lib.js</code> 和 <code>lib.node.js</code> 文件。</p> <h2 id="resources">资源 <a href="#resources" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>从上面选项可以看出，你可以选择部署不同的 <em>target</em>。下面是可以参考的示例和资源：</p> <ul> <li><strong><a href="javascript:if(confirm('https://github.com/TheLarkInn/compare-webpack-target-bundles  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/TheLarkInn/compare-webpack-target-bundles'" tppabs="https://github.com/TheLarkInn/compare-webpack-target-bundles">compare-webpack-target-bundles</a></strong>：测试并查看 webpack <em>target</em> 的绝佳资源。同样包含错误上报。</li> <li><strong><a href="javascript:if(confirm('https://github.com/chentsulin/electron-react-boilerplate  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/chentsulin/electron-react-boilerplate'" tppabs="https://github.com/chentsulin/electron-react-boilerplate">Boilerplate of Electron-React Application</a></strong>: 一个关于 electron 主进程和渲染进程构建过程的优秀示例。</li> </ul> <blockquote class="todo"> <p>需要你查看在线代码或样本中 webpack 配置中使用的 target 示例。</p> </blockquote> <h1 id="manifest">manifest<a href="#manifest" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h1> <p>在使用 webpack 构建的典型应用程序或站点中，有三种主要的代码类型：</p> <ol> <li>你或你的团队编写的源码。</li> <li>你的源码会依赖的任何第三方的 library 或 "vendor" 代码。</li> <li>webpack 的 runtime 和 <strong>manifest</strong>，管理所有模块的交互。</li> </ol> <p>本文将重点介绍这三个部分中的最后部分：runtime 和 manifest，特别是 manifest。</p> <h2 id="runtime">runtime <a href="#runtime" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>runtime，以及伴随的 manifest 数据，主要是指：在浏览器运行过程中，webpack 用来连接模块化应用程序所需的所有代码。它包含：在模块交互时，连接模块所需的加载和解析逻辑。包括：已经加载到浏览器中的连接模块逻辑，以及尚未加载模块的延迟加载逻辑。</p> <h2 id="manifest">manifest <a href="#manifest" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>一旦你的应用在浏览器中以 <code>index.html</code> 文件的形式被打开，一些 bundle 和应用需要的各种资源都需要用某种方式被加载与链接起来。在经过打包、压缩、为延迟加载而拆分为细小的 chunk 这些 webpack <a href="../../configuration/optimization/index.htm" tppabs="https://webpack.docschina.org/configuration/optimization/"><code>优化</code></a> 之后，你精心安排的 <code>/src</code> 目录的文件结构都已经不再存在。所以 webpack 如何管理所有所需模块之间的交互呢？这就是 manifest 数据用途的由来……</p> <p>当 compiler 开始执行、解析和映射应用程序时，它会保留所有模块的详细要点。这个数据集合称为 "manifest"，当完成打包并发送到浏览器时，runtime 会通过 manifest 来解析和加载模块。无论你选择哪种 <a href="../../api/module-methods.htm" tppabs="https://webpack.docschina.org/api/module-methods">模块语法</a>，那些 <code>import</code> 或 <code>require</code> 语句现在都已经转换为 <code>__webpack_require__</code> 方法，此方法指向模块标识符(module identifier)。通过使用 manifest 中的数据，runtime 将能够检索这些标识符，找出每个标识符背后对应的模块。</p> <h2 id="the-problem">问题 <a href="#the-problem" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>所以，现在你应该对 webpack 在幕后工作有一点了解。“但是，这对我有什么影响呢？”，你可能会问。答案是大多数情况下没有。runtime 做完成这些工作：一旦你的应用程序加载到浏览器中，使用 manifest，然后所有内容将展现出魔幻般运行结果。然而，如果你决定通过使用浏览器缓存来改善项目的性能，理解这一过程将突然变得极为重要。</p> <p>通过使用内容散列(content hash)作为 bundle 文件的名称，这样在文件内容修改时，会计算出新的 hash，浏览器会使用新的名称加载文件，从而使缓存无效。一旦你开始这样做，你会立即注意到一些有趣的行为。即使某些内容明显没有修改，某些 hash 还是会改变。这是因为，注入的 runtime 和 manifest 在每次构建后都会发生变化。</p> <p>查看_管理输出_指南的 <a href="../../guides/output-management/index.htm#the-manifest" tppabs="https://webpack.docschina.org/guides/output-management/#the-manifest">manifest 部分</a>，了解如何提取 manifest，并阅读下面的指南，以了解更多长效缓存错综复杂之处。</p> <h1 id="模块热替换hot-module-replacement">模块热替换(hot module replacement)<a href="#%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%BF%E6%8D%A2hot-module-replacement" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h1> <p>模块热替换(HMR - hot module replacement)功能会在应用程序运行过程中，替换、添加或删除 <a href="../modules/index.htm" tppabs="https://webpack.docschina.org/concepts/modules/">模块</a>，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度：</p> <ul> <li>保留在完全重新加载页面期间丢失的应用程序状态。</li> <li>只更新变更内容，以节省宝贵的开发时间。</li> <li>在源代码中 CSS/JS 产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。</li> </ul> <h2 id="how-it-works">这一切是如何运行的？ <a href="#how-it-works" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>让我们从一些不同的角度观察，以了解 HMR 的工作原理……</p> <h3 id="in-the-application">在应用程序中 <a href="#in-the-application" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p>通过以下步骤，可以做到在应用程序中置换(swap in and out)模块：</p> <ol> <li>应用程序要求 HMR runtime 检查更新。</li> <li>HMR runtime 异步地下载更新，然后通知应用程序。</li> <li>应用程序要求 HMR runtime 应用更新。</li> <li>HMR runtime 同步地应用更新。</li> </ol> <p>你可以设置 HMR，以使此进程自动触发更新，或者你可以选择要求在用户交互时进行更新。</p> <h3 id="in-the-compiler">在 compiler 中 <a href="#in-the-compiler" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p>除了普通资源，compiler 需要发出 "update"，将之前的版本更新到新的版本。"update" 由两部分组成：</p> <ol> <li>更新后的 <a href="../manifest.htm" tppabs="https://webpack.docschina.org/concepts/manifest">manifest</a> (JSON)</li> <li>一个或多个 updated chunk (JavaScript)</li> </ol> <p>manifest 包括新的 compilation hash 和所有的 updated chunk 列表。每个 chunk 都包含着全部更新模块的最新代码（或一个 flag 用于表明此模块需要被移除）。</p> <p>compiler 会确保在这些构建之间的模块 ID 和 chunk ID 保持一致。通常将这些 ID 存储在内存中（例如，使用 <a href="../../configuration/dev-server/index.htm" tppabs="https://webpack.docschina.org/configuration/dev-server/">webpack-dev-server</a> 时），但是也可能会将它们存储在一个 JSON 文件中。</p> <h3 id="in-a-module">在模块中 <a href="#in-a-module" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p>HMR 是可选功能，只会影响包含 HMR 代码的模块。举个例子，通过 <a href="javascript:if(confirm('https://github.com/webpack-contrib/style-loader  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/webpack-contrib/style-loader'" tppabs="https://github.com/webpack-contrib/style-loader"><code>style-loader</code></a> 为 style 追加补丁。为了运行追加补丁，<code>style-loader</code> 实现了 HMR 接口；当它通过 HMR 接收到更新，它会使用新的样式替换旧的样式。</p> <p>类似的，当在一个模块中实现了 HMR 接口，你可以描述出当模块被更新后发生了什么。然而在多数情况下，不需要在每个模块中强行写入 HMR 代码。如果一个模块没有 HMR 处理函数，更新就会冒泡(bubble up)。这意味着某个单独处理函数能够更新整个模块树。如果在模块树的一个单独模块被更新，那么整组依赖模块都会被重新加载。</p> <p>有关 <code>module.hot</code> 接口的详细信息，请查看 <a href="../../api/hot-module-replacement.htm" tppabs="https://webpack.docschina.org/api/hot-module-replacement">HMR API 页面</a>。</p> <h3 id="in-the-runtime">在 runtime 中 <a href="#in-the-runtime" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h3> <p>这件事情比较有技术性……如果你对其内部不感兴趣，可以随时跳到 <a href="../../api/hot-module-replacement.htm" tppabs="https://webpack.docschina.org/api/hot-module-replacement">HMR API 页面</a> 或 <a href="../../guides/hot-module-replacement.htm" tppabs="https://webpack.docschina.org/guides/hot-module-replacement">HMR 指南</a>。</p> <p>对于模块系统运行时(module system runtime)，会发出额外代码，来跟踪模块 <code>parents</code> 和 <code>children</code> 关系。在管理方面，runtime 支持两个方法 <code>check</code> 和 <code>apply</code>。</p> <p><code>check</code> 方法，发送一个 HTTP 请求来更新 manifest。如果请求失败，说明没有可用更新。如果请求成功，会将 updated chunk 列表与当前的 loaded chunk 列表进行比较。每个 loaded chunk 都会下载相应的 updated chunk。当所有更新 chunk 完成下载，runtime 就会切换到 <code>ready</code> 状态。</p> <p><code>apply</code> 方法，将所有 updated module 标记为无效。对于每个无效 module，都需要在模块中有一个 update handler，或者在此模块的父级模块中有 update handler。否则，会进行无效标记冒泡，并且父级也会被标记为无效。继续每个冒泡，直到到达应用程序入口起点，或者到达带有 update handler 的 module（以最先到达为准，冒泡停止）。如果它从入口起点开始冒泡，则此过程失败。</p> <p>之后，所有无效 module 都会被（通过 dispose handler）处理和解除加载。然后更新当前 hash，并且调用所有 <code>accept</code> handler。runtime 切换回 <code>idle</code> 状态，一切照常继续。</p> <h2 id="get-started">起步 <a href="#get-started" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>在开发环境，可以将 HMR 作为 LiveReload 的替代。<a href="../../configuration/dev-server/index.htm" tppabs="https://webpack.docschina.org/configuration/dev-server/">webpack-dev-server</a> 支持 <code>hot</code> 模式，在试图重新加载整个页面之前，<code>hot</code> 模式会尝试使用 HMR 来更新。更多细节请查看 <a href="../../guides/hot-module-replacement.htm" tppabs="https://webpack.docschina.org/guides/hot-module-replacement">模块热替换</a> 指南。</p> <blockquote class="tip"> <p>与许多其他功能一样，webpack 的强大之处在于它的可定制化。取决于特定项目需求，会有_许多方式_来配置 HMR。然而，对于多数项目的实现目的来说，<code>webpack-dev-server</code> 都能够很好适应，可以帮助你在项目中快速应用 HMR。</p> </blockquote> <h1 id="为什么选择-webpack">为什么选择 webpack<a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-webpack" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h1> <p>想要理解为什么要使用 webpack，我们先回顾下历史，在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的。</p> <p>在浏览器中运行 JavaScript 有两种方法。第一种方式，引用一些脚本来存放每个功能；此解决方案很难扩展，因为加载太多脚本会导致网络瓶颈。第二种方式，使用一个包含所有项目代码的大型 <code>.js</code> 文件，但是这会导致作用域、文件大小、可读性和可维护性方面的问题。</p> <h2 id="iifes---immediately-invoked-function-expressions">立即调用函数表达式(IIFE) - Immediately invoked function expressions <a href="#iifes---immediately-invoked-function-expressions" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>IIFE 解决大型项目的作用域问题；当脚本文件被封装在 IIFE 内部时，你可以安全地拼接或安全地组合所有文件，而不必担心作用域冲突。</p> <p>IIFE 使用方式产生出 Make, Gulp, Grunt, Broccoli 或 Brunch 等工具。这些工具称为任务执行器，它们将所有项目文件拼接在一起。</p> <p>但是，修改一个文件意味着必须重新构建整个文件。拼接可以做到很容易地跨文件重用脚本，但是却使构建结果的优化变得更加困难。如何判断代码是否实际被使用？</p> <p>即使你只用到 lodash 中的某个函数，也必须在构建结果中加入整个库，然后将它们压缩在一起。如何 treeshake 代码依赖？难以大规模地实现延迟加载代码块，这需要开发人员手动地进行大量工作。</p> <h2 id="birth-of-javascript-modules-happened-thanks-to-nodejs">感谢 Node.js，JavaScript 模块诞生了 <a href="#birth-of-javascript-modules-happened-thanks-to-nodejs" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>Node.js 是一个 JavaScript 运行时，可以在浏览器环境之外的计算机和服务器中使用。webpack 运行在 Node.js 中。</p> <p>当 Node.js 发布时，一个新的时代开始了，它带来了新的挑战。既然不是在浏览器中运行 JavaScript，现在已经没有了可以添加到浏览器中的 html 文件和 script 标签。那么 Node.js 应用程序要如何加载新的代码 chunk 呢？</p> <p>CommonJS 问世并引入了 <code>require</code> 机制，它允许你在当前文件中加载和使用某个模块。导入需要的每个模块，这一开箱即用的功能，帮助我们解决了作用域问题。</p> <h2 id="npm--nodejs--modules----mass-distribution">npm + Node.js + modules - 大规模分发模块 <a href="#npm--nodejs--modules----mass-distribution" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>JavaScript 已经成为一种语言、一个平台和一种快速开发和创建快速应用程序的方式，接管了整个 JavaScript 世界。</p> <p>但 CommonJS 没有浏览器支持。没有 <a href="javascript:if(confirm('https://medium.com/webpack/the-state-of-javascript-modules-4636d1774358  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://medium.com/webpack/the-state-of-javascript-modules-4636d1774358'" tppabs="https://medium.com/webpack/the-state-of-javascript-modules-4636d1774358">live binding(实时绑定)</a>。循环引用存在问题。同步执行的模块解析加载器速度很慢。虽然 CommonJS 是 Node.js 项目的绝佳解决方案，但浏览器不支持模块，因而产生了 Browserify, RequireJS 和 SystemJS 等打包工具，允许我们编写能够在浏览器中运行的 CommonJS 模块。</p> <h2 id="esm---ecmascript-modules">ESM - ECMAScript 模块 <a href="#esm---ecmascript-modules" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>来自 Web 项目的好消息是，模块正在成为 ECMAScript 标准的官方功能。然而，浏览器支持不完整，版本迭代速度也不够快，目前还是推荐上面那些早期模块实现。</p> <h2 id="automatic-dependency-collection">依赖自动收集 <a href="#automatic-dependency-collection" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>传统的任务构建工具基于 Google 的 Closure 编译器都要求你手动在顶部声明所有的依赖。然而像 webpack 一类的打包工具自动构建并基于你所引用或导出的内容推断出<a href="../dependency-graph/index.htm" tppabs="https://webpack.docschina.org/concepts/dependency-graph/">依赖的图谱</a>。这个特性与其它的如<a href="../plugins/index.htm" tppabs="https://webpack.docschina.org/concepts/plugins/">插件</a> and <a href="../loaders/index.htm" tppabs="https://webpack.docschina.org/concepts/loaders/">加载器</a>一道让开发者的体验更好。</p> <h2 id="wouldnt-it-be-nice">看起来都不是很好…… <a href="#wouldnt-it-be-nice" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>是否可以有一种方式，不仅可以让我们编写模块，而且还支持任何模块格式（至少在我们到达 ESM 之前），并且可以同时处理资源和资产？</p> <p>这就是 webpack 存在的原因。它是一个工具，可以打包你的 JavaScript 应用程序（支持 ESM 和 CommonJS），可以扩展为支持许多不同的资产，例如：images, fonts 和 stylesheets。</p> <p>webpack 关心性能和加载时间；它始终在改进或添加新功能，例如：异步地加载 chunk 和预取，以便为你的项目和用户提供最佳体验。</p> <h1 id="揭示内部原理">揭示内部原理<a href="#%E6%8F%AD%E7%A4%BA%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h1> <blockquote> <p>此章节描述 webpack 内部实现，对于插件开发人员可能会提供帮助</p> </blockquote> <p>打包，是指处理某些文件并将其输出为其他文件的能力。</p> <p>但是，在输入和输出之间，还包括有 <a href="../modules/index.htm" tppabs="https://webpack.docschina.org/concepts/modules/">模块</a>, <a href="../entry-points/index.htm" tppabs="https://webpack.docschina.org/concepts/entry-points/">入口起点</a>, chunk, chunk 组和许多其他中间部分。</p> <h2 id="the-main-parts">主要部分 <a href="#the-main-parts" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>项目中使用的每个文件都是一个 <a href="../modules/index.htm" tppabs="https://webpack.docschina.org/concepts/modules/">模块</a></p> <p><strong>./index.js</strong></p> <pre><code class="hljs language-js"><span class="token keyword">import</span> app <span class="token keyword">from</span> <span class="token string">'./app.js'</span><span class="token punctuation">;</span></code></pre> <p><strong>./app.js</strong></p> <pre><code class="hljs language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token string">'the app'</span><span class="token punctuation">;</span></code></pre> <p>通过互相引用，这些模块会形成一个图(<code>ModuleGraph</code>)数据结构。</p> <p>在打包过程中，模块会被合并成 chunk。 chunk 合并成 chunk 组，并形成一个通过模块互相连接的图(<code>ModuleGraph</code>)。 那么如何通过以上来描述一个入口起点：在其内部，会创建一个只有一个 chunk 的 chunk 组。</p> <p><strong>./webpack.config.js</strong></p> <pre><code class="hljs language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./index.js'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p>这会创建出一个名为 <code>main</code> 的 chunk 组（<code>main</code> 是入口起点的默认名称）。 此 chunk 组包含 <code>./index.js</code> 模块。随着 parser 处理 <code>./index.js</code> 内部的 import 时， 新模块就会被添加到此 chunk 中。</p> <p>另外的一个示例：</p> <p><strong>./webpack.config.js</strong></p> <pre><code class="hljs language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token punctuation">{</span>
    home<span class="token operator">:</span> <span class="token string">'./home.js'</span><span class="token punctuation">,</span>
    about<span class="token operator">:</span> <span class="token string">'./about.js'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p>这会创建出两个名为 <code>home</code> 和 <code>about</code> 的 chunk 组。 每个 chunk 组都有一个包含一个模块的 chunk：<code>./home.js</code> 对应 <code>home</code>，<code>./about.js</code> 对应 <code>about</code></p> <blockquote> <p>一个 chunk 组中可能有多个 chunk。例如，<a href="../../plugins/split-chunks-plugin/index.htm" tppabs="https://webpack.docschina.org/plugins/split-chunks-plugin/">SplitChunksPlugin</a> 会将一个 chunk 拆分为一个或多个 chunk。</p> </blockquote> <h2 id="chunks">chunk <a href="#chunks" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>chunk 有两种形式：</p> <ul> <li><code>initial(初始化)</code> 是入口起点的 main chunk。此 chunk 包含为入口起点指定的所有模块及其依赖项。</li> <li><code>non-initial</code> 是可以延迟加载的块。可能会出现在使用 <a href="../../guides/code-splitting/index.htm#dynamic-imports" tppabs="https://webpack.docschina.org/guides/code-splitting/#dynamic-imports">动态导入(dynamic imports)</a> 或者 <a href="../../plugins/split-chunks-plugin/index.htm" tppabs="https://webpack.docschina.org/plugins/split-chunks-plugin/">SplitChunksPlugin</a> 时。</li> </ul> <p>每个 chunk 都有对应的 <strong>asset(资源)</strong>。资源，是指输出文件（即打包结果）。</p> <p><strong>webpack.config.js</strong></p> <pre><code class="hljs language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token operator">:</span> <span class="token string">'./src/index.jsx'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre> <p><strong>./src/index.jsx</strong></p> <pre><code class="hljs language-js"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span>

<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./app.jsx'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">App</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span>App <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p>这会创建出一个名为 <code>main</code> 的 initial chunk。其中包含：</p> <ul> <li><code>./src/index.jsx</code></li> <li><code>react</code></li> <li><code>react-dom</code></li> </ul> <p>以及除 <code>./app.jsx</code> 外的所有依赖</p> <p>然后会为 <code>./app.jsx</code> 创建 non-initial chunk，这是因为 <code>./app.jsx</code> 是动态导入的。</p> <p><strong>Output:</strong></p> <ul> <li><code>/dist/main.js</code> - 一个 <code>initial</code> chunk</li> <li><code>/dist/394.js</code> - <code>non-initial</code> chunk</li> </ul> <p>默认情况下，这些 <code>non-initial</code> chunk 没有名称，因此会使用唯一 ID 来替代名称。 在使用动态导入时，我们可以通过使用 <a href="../../api/module-methods/index.htm#magic-comments" tppabs="https://webpack.docschina.org/api/module-methods/#magic-comments">magic comment(魔术注释)</a> 来显式指定 chunk 名称：</p> <pre><code class="hljs language-js"><span class="token keyword">import</span><span class="token punctuation">(</span>
  <span class="token comment">/* webpackChunkName: "app" */</span>
  <span class="token string">'./app.jsx'</span>
<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">App</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&#x3C;</span>App <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre> <p><strong>Output:</strong></p> <ul> <li><code>/dist/main.js</code> - 一个 <code>initial</code> chunk</li> <li><code>/dist/app.js</code> - <code>non-initial</code> chunk</li> </ul> <h2 id="output">output(输出) <a href="#output" aria-hidden="true" tabindex="-1"><span class="header-link"></span></a></h2> <p>输出文件的名称会受配置中的两个字段的影响：</p> <ul> <li><a href="../../configuration/output/index.htm#outputfilename" tppabs="https://webpack.docschina.org/configuration/output/#outputfilename"><code>output.filename</code></a> - 用于 <code>initial</code> chunk 文件</li> <li><a href="../../configuration/output/index.htm#outputchunkfilename" tppabs="https://webpack.docschina.org/configuration/output/#outputchunkfilename"><code>output.chunkFilename</code></a> - 用于 <code>non-initial</code> chunk 文件</li> <li>在某些情况下，使用 <code>initial</code> 和 <code>non-initial</code> 的 chunk 时，可以使用 <code>output.filename</code>。</li> </ul> <p>这些字段中会有一些 <a href="../../configuration/output/index.htm#template-strings" tppabs="https://webpack.docschina.org/configuration/output/#template-strings">占位符</a>。常用的占位符如下：</p> <ul> <li><code>[id]</code> - chunk id（例如 <code>[id].js</code> -> <code>485.js</code>）</li> <li><code>[name]</code> - chunk name（例如 <code>[name].js</code> -> <code>app.js</code>）。如果 chunk 没有名称，则会使用其 id 作为名称</li> <li><code>[contenthash]</code> - 输出文件内容的 md4-hash（例如 <code>[contenthash].js</code> -> <code>4ea6ff1de66c537eb9b2.js</code>）</li> </ul> </div><div class="contributors__section"><hr/><h3>Contributors</h3><div class="contributors"><div class="contributors__list"><a class="contributor" href="javascript:if(confirm('https://github.com/webpack  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/webpack'" tppabs="https://github.com/webpack"><img alt="webpack" src="../../icon-square-small-slack.9281492bb267314634b4.png" tppabs="https://webpack.docschina.org/icon-square-small-slack.9281492bb267314634b4.png"/><span class="contributor__name"> <!-- -->webpack</span></a></div></div></div></div></section></div><footer class="footer"><div class="container footer__inner"><section class="footer__left"><a class="footer__link" href="../../guides/getting-started/index.htm" tppabs="https://webpack.docschina.org/guides/getting-started/">起步</a><a class="footer__link" href="../../organization/index.htm" tppabs="https://webpack.docschina.org/organization/">组织</a><a class="footer__link" href="../../comparison/index.htm" tppabs="https://webpack.docschina.org/comparison/">比较</a></section><section class="footer__middle"><a class="footer__icon" href="../../index-1.htm" tppabs="https://webpack.docschina.org/"><img src="../../icon-square-small.85ba630cf0c5f29ae3e3.svg" tppabs="https://webpack.docschina.org/icon-square-small.85ba630cf0c5f29ae3e3.svg" alt="webpack icon"/></a></section><section class="footer__right"><a href="javascript:if(confirm('https://webpack.threadless.com/  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://webpack.threadless.com/'" tppabs="https://webpack.threadless.com/" target="_blank" rel="noopener noreferrer" class="footer__link">商店</a><a class="footer__link" href="../../glossary/index.htm" tppabs="https://webpack.docschina.org/glossary/">概念术语</a><a class="footer__link" href="../../branding/index.htm" tppabs="https://webpack.docschina.org/branding/">品牌</a><a href="javascript:if(confirm('https://gitter.im/webpack/webpack  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://gitter.im/webpack/webpack'" tppabs="https://gitter.im/webpack/webpack" target="_blank" rel="noopener noreferrer" class="footer__link">Gitter</a><a href="javascript:if(confirm('https://github.com/webpack/webpack/releases  \n\nļ޷ Teleport Ultra , Ϊ һ·ⲿΪʼַĵַ  \n\nڷϴ?'))window.location='https://github.com/webpack/webpack/releases'" tppabs="https://github.com/webpack/webpack/releases" target="_blank" rel="noopener noreferrer" class="footer__link">更新日志</a><a class="footer__link footer__license" href="../../license.htm" tppabs="https://webpack.docschina.org/license"><img alt="Creative Commons License" src="../../cc.ab77d813bf219c6e34ff.svg" tppabs="https://webpack.docschina.org/cc.ab77d813bf219c6e34ff.svg"/><img alt="Creative Commons License" src="../../by.1360bb2e6d1fc28cdd9e.svg" tppabs="https://webpack.docschina.org/by.1360bb2e6d1fc28cdd9e.svg"/></a></section></div></footer></div></div><script>
window.matchMedia('print').addListener(function(mql) {
  if (!mql.matches) {
      window.close();
  }
});
window.print();
</script><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "../../../hm.baidu.com/hm.js-39edd8e76884f07399be96cd422c9af3"/*tpa=https://hm.baidu.com/hm.js?39edd8e76884f07399be96cd422c9af3*/;
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script></body></html>