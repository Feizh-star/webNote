### HTML

1. 特殊的标签属性
   * `<link rel="dns-prefetch" href="[//static.360buyimg.com](https://static.360buyimg.com/)"/>`
     * DNS 预解析：可以根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到`系统缓存`中，缩短DNS解析时间，来提高网站的访问速度
   * `<meta name="renderer" content="webkit"/>`
     * 如果是双核浏览器，优先使用webkit内核
   * `<meta name="description" content="京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!"/>`
     * 网站描述，供搜索引擎使用
   * `<meta name="Keywords" content="网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东"/>`
     * 关键字，供搜索引擎识别
   * `<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>`
     * 浏览器渲染相关

### JS

1. JS 哪些操作会造成内存泄露?

   * 1.意外的全局变量；2.闭包；3.没有清理的DOM引用；4.被遗忘的定时器；5.子元素存在引用

2. JS 中执行上下文的类型有哪些？

   * 1.全局执行上下文；2.函数执行上下文；3.eval函数执行上下文；

3. JS的数据类型？如何判断js的数据类型?
   * 基本类型：Number、String、Boolean、null、undefined、Symbol
   * 引用类型：Object
   * 判断方法：
     * typeof：字符串-string，数字和NaN-number，布尔-boolean，函数-function，数组/对象/null-object，Symbol()-symbol
     * instanceof                
     * constructor
     * Object.prototype.toString.call()

4. 说一下ES6的新特性有哪些？
   * let、const
   * 解构赋值
   * 字符串（includes、startsWith、endsWith）、数组（find、findIndex、flat）扩展方法
   * 箭头函数、默认参数、rest参数
   * class语法糖
   * es6导入导出
   * Promise
   * for...of循环
   * Set、Map
   * Proxy
   * Iterator：数据结构的原型上有个遍历器生成函数，调用它返回一个遍历器对象，遍历器对象有个指针指向数据结构的起始位置，每调用1次next方法就返回当前位置的值，并将指针向后移动
   * generator
   * async await

5. let、const、var三者的区别

   * 重复声明、块级作用域、是否常量、变量提升、暂时性死区、let只能在当前作用域的顶层（`if (true) let a = 0`将报错）

6. 数组去重有哪些方法？

   * 利用set
   * 数组迭代

7. 说一下深拷贝和浅拷贝，如何自己实现一个深拷贝？（非标准答案）

   * 深拷贝就是对象的属性值也是对象，要将属性的值也进行拷贝，需要递归
   * 浅拷贝就是只考虑1层

8. 说一下防抖和节流。怎么实现？

   * 防抖：某个操作在指定周期内连续触发，只执行1次
   * 节流：某个操作连续触发，在每个指定周期内只执行1次

   ```js
   // 防抖
   function debounce(fn, wait) {
       let timer
       return function (...args) {
           if (timer) clearTimeout(timer)
           timer = setTimeout(() => {
               fn.call(this, ...args)
           }, wait)
       }
   }
   // 节流：通过定时器是否存在来决定周期
   function throttling(fn, wait, immediate) {
       let timer = null
       return function (...args) {
           if (timer) return
           if (immediate) fn.call(this, ...args)
           timer = setTimeout(() => {
               clearTimeout(timer)
               timer = null
               if (!immediate) fn.call(this, ...args)
           }, wait)
       }
   }
   ```

9. 闭包是什么？如何实现？

   * 闭包：是函数与它声明时所处的环境的一种作用域关系
   * 实现：就是在函数体中使用它外部声明的变量，这个变量在外部上下文执行完后不会销毁，而会一直存在供这个函数使用

10. 用闭包的原理做过哪些？

  * 防抖、节流
  * vue的数据劫持也利用了闭包

11. 什么是Js原型？原型链是什么？

    * js中每一个对象都有一个\__proto__属性就是它的原型，这个原型通过constructor指向构造函数，构造函数通过prototype指向原型，形成了一个三角关系
    * 对象的原型也是一个对象，这个对象也有它的原型，这样原型之间逐个连接就形成了原型链，原型链使得js可以实现继承

12. 作用域是什么？

    * 每一个变量都有其可使用的范围，这个范围就是作用域；
    * es5有两种作用域：全局作用域和函数作用域；let和const具有块级作用域；
    * 作用域链：作用域中还可以定义函数或块，这样就形成了层级关系，即作用域链

13. 操作数组的方法有哪些？

    * 变异方法：push/pop、unshift/shift、sort、reverse、splice
    * 非变异方法：slice、concat、join、find、includes、every、some、map

14. 对数组元素进行分组，例如学生信息数组按年龄分组

    * 使用对象/Map，使用年龄作为key，value是一个数组，遍历学生数组，把对应年龄的对象放进去

15. 0.1 + 0.2 等于 0.3吗？为什么？如何解决？

    * 不等于，因为他俩在以二进制存储时是无限循环小数，也就是会损失精度，所以得到的结果不等于0.3
    * 解决：可以先将小数扩大10^m倍，变成整数加法，再缩小10^m倍（m是两个数中的最大小数位数）；

16. 精确计算

    * 加减法：可以先将小数扩大10^m倍，变成整数加/减法，再缩小10^m倍（m是两个数中的最大小数位数）；
    * 乘法：将浮点数通过去掉小数点的方法转成整数；整数乘法；再除以10的n（两个运算数小数位数之和）次幂
    * 除法：将浮点数通过去掉小数点的方法转成整数；整数除法；再除以10的n（两个运算数小数位数之差）次幂

17. 判断一个变量是否是数组，有哪些办法？

    * Array.isArray()
    * instanceof
    * Object.prototype.toString.call()
    * arr.\__proto__ \=== Array.prototype 或 constructor

18. 判断一个变量是否是对象，有哪些办法？

    * instanceof：不能区分对象的类型
    * arr.\__proto__ \=== Object.prototype 或 constructor
    * Object.prototype.toString.call()

19. 对象常用方法有哪些？

    * toString()、hasOwnProperty()（可判断不可枚举属性）、valueOf()

20. 创建一个空对象有哪些方式？

    * 直接定义：`let a = {}`
    * 构造函数：`new Object()`
    * 工厂函数
    * 类的构造函数
    * 对象：Object.create()

21. 创建一个空数组有哪些方式？

    * 直接定义：`let a = []`
    * 构造函数：`new Array()`

22. Set和Map各是什么？

    * Set是集合；Map是映射表；它们都是es6增加的内置数据结构

23. 介绍一下Promise

    * Promise是为了解决js的回调地狱而诞生的一个内置对象，它封装异步操作，并使得异步操作可以进行链式回调。

24. Promise通常会解决三种问题

    * 回调地狱——链式回调

    * 同时发起几个异步请求，谁先有结果就拿谁的——Promise.race([])

    * 发起多个请求，等到所有请求后再做下一步处理——Promise.all([])和Promise.allSettled()

    * Promise.race([p1, p2, p3])：返回一个新的promise，谁先有结果就拿谁的结果（无论成败）

    * Promise.any([p1, p2, p3])：返回一个新的promise，谁先成功就拿谁的结果（全部失败才失败）

    * Promise.all([p1, p2, p3])：返回一个新的promise，全部成功则成功，有一个失败则失败

    * Promise.allSettled(p1, p2, p3)：返回一个新的promise，等待所有结果，返回所有的结果

      `[{status: 'fulfilled', value: value1}, {status: 'reject', value: value2}]`

    * Promise.resolve()：将参数转为promise对象，参数可以是以下情况

      * promise对象：什么都不做，原封不动地返回这个promise对象
      * 一个具有then方法的对象：会把这个对象转为promise，然后立即执行这个对象的then方法
      * 原始值或没有then方法的对象：返回的promise对象直接resolve并把这个参数作为结果
      * 没有任何参数：直接返回一个resolve的promise对象

    * Promise.reject()：返回一个状态是reject的promise

25. 如何改变一个函数a的上下文？

    * call、apply、bind

26. call和apply有什么区别？

    * call接收参数列表；apply接收一个数组作为参数列表

27. Evenbus是什么东西？

    * 总线，是一个vue实例，用来传递全局事件，实现任意组件之间通信

28. new运算符的工作过程，以new Foo()为例

    * 创建1个新对象，修改它的原型为 构造函数的prototype
    * 构造函数中的this指向这个对象
    * 执行构造函数体
    * 返回这个新对象
      * 如果构造函数中返回了1个对象，则返回这个对象，而非上述创建的新对象

29. this指向问题

    * **普通函数**中的this-------->指向window

    * **构造函数**中的this-------->指向new创建的新的空对象

      > 构造函数中的this其实是一个隐式对象，类似一个初始化的模型，所有方法和属性都挂载到了这个隐式对象身上，后续通过new关键字来调用，从而实现实例化

    * **方法**中的this ----------->指向方法所属的对象（调用方法的对象）

    * **事件处理函数**中的this---->事件源，即指向注册该事件的元素对象

30. js如何实现继承

    * 借用构造函数：即在子类的构造函数中调用父类的构造函数（当然要通过call修改this指向）
      * 优点：可以继承父类的实例属性，这些属性会作为子类的实例属性（在子类实例自己身上）
      * 缺点：无法继承父类的实例方法，因为实例方法一般会放在原型上
    * 原型继承：即修改子类构造函数的prototype属性，使之为 父类的1个实例
      * 优点：解决了父类实例方法的继承问题，因为子类实例调用方法时，会沿着原型链向上找
      * 缺点：每创建1个子类的实例，父类构造函数就要被调用两次；且父类的实例属性会残留在子类的prototype上，其实并没有什么作用
    * 优化1：子类构造函数.prototype = Object.create(父类构造函数.prototype)
      * 利用Object.create()，创建1个新的空对象，作为子类的 prototype；由于此方法的特点，这个空对象的\__proto__就是父类的prototype
      * 优点：解决了 以父类实例作为子类原型的问题（构造函数重复调用；父类属性残留在子类原型）
      * 缺点：无法判断一个子类的实例 是父类还是子类的实例（instanceof 和 实例.constructor 都不行）
    * 优化2：修改 子类构造函数.prototype.constructor = 子类构造函数
      * 优点：解决了 子类的类型判断问题
      * 缺点：其实没啥了，非要说缺点的话，就是不够优雅，所以可以用ES6

31. 什么是面向对象

    * 面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。**它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。**
    * 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。
    * 因此，面向对象编程具有**灵活**、代码可**复用**、高度**模块**化等特点，容易**维护**和**开发**，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。
    * tips：灵复模维开

32. 如何理解js单线程

    * 同一时刻，js引擎只能做1件事

33. 什么是事件循环

    * 事件循环：就是1个循环，不停地检查任务队列是否为空
    * 如果任务队列不为空，则就把队列中的任务依次取出，放入执行栈处理，这就是当前的同步任务，同步任务处理完，就再次查看任务队列是否为空

34. 什么是任务队列

    * js任务类型：同步任务（就是在当前上下文中同步执行的代码）和异步任务（就是当前同步任务中的定时器、事件、网络请求）
    * js主线程在遇到异步任务时，会把异步任务交给相应的模块去处理，而自己继续向下执行同步任务
    * 当异步任务触发事件时（定时器到期、DOM事件触发、拿到网络请求的响应），相应的回调就会被放进任务队列

35. 宏任务都有哪些

    * script标签中的同步代码；ajax；DOM事件；setTimeout/setInterval；postMessage；MessageChannel（通信管道）；setImmediate(Node.js 环境)

36. 微任务都有哪些

    * Promise.then/catch/finally，Object.observe，MutationObserver，process.nextTick(Node.js 环境)

    * Object.observe——对对象的属性进行观察

      ```js
      Object.observe(obj, function (changes) {})
      ```

    * MutationObserver——对DOM进行观察

      ```js
      const config = { attributes: true, childList: true, subtree: true };
      const observer = new MutationObserver(callback); // callback是观察到变动后的回调
      observer.observe(targetNode, config); // 开始观察targetNode
      observer.disconnect(); // 停止观察
      ```

37. 宏任务和微任务的处理顺序

    * 当前同步任务执行完毕后，执行微任务，将微任务队列清空后，取一个宏任务，执行完再清一遍微任务

38. 对对象或数组进行监听

    * Object.observe
    * defineProperty
    * Proxy

### WebAPI

1. 如何使用js获取 盒子的宽高
   * ele.offsetWidth / ele.offsetHeight
   * ele.getBundingClientRect()
   * *window.getComputedStyle(ele).width / height*
2. DOM事件的级别：DOM0、DOM2、DOM3
   * DOM0：就是ele.onclick = function(){}
     * 只能为1个元素的1个事件注册1个方法，且不能设置触发的阶段
   * DOM2：就是ele.addEventListener('click', function(){}, false)（第3个参数默认为false，即事件方法在冒泡阶段执行）
     * 可以为1个事件注册多个方法，可以设置事件触发的阶段
   * DOM3：还是ele.addEventListener('click', function(){}, false)
     * 增加了一些 事件，例如键盘事件、鼠标事件
3. DOM事件模型：就是一个事件触发，分为捕获阶段、目标阶段、冒泡阶段
   * 捕获阶段：事件流在DOM树自上而下传递
   * 目标阶段：事件流到达目标元素（例如被点击的元素）
   * 冒泡阶段：事件流从目标元素沿着DOM树向上传递
4. 描述DOM事件捕获的具体流程（事件流的详情，事件冒泡就是反过来）
   * window：事件第一个到达的对象是window
   * document：第二个对象是document
   * html：第三个对象是html元素（获取html元素的方式：document.documentElement）
   * body：第四个对象是body元素（获取body元素的方式：1.和普通元素一样；2.document.body）
   * ...具体的DOM结构
   * 目标元素：事件发生的元素
5. Event对象的常见应用：
   * Event.preventDefault()：阻止默认行为
   * Event.stopPropagation()：阻止事件冒泡
   * Event.stopImmediatePropagation()：处理事件优先级
     * addEventListener添加的事件处理函数（同一事件），当事件触发时，会按照添加顺序依次执行，例如a、b
     * 在a（先执行）中调用Event.stopImmediatePropagation()，就可以阻止后续的b执行
   * Event.target：真正触发事件的DOM元素
   * Event.currentTarget：事件处理函数所在的DOM元素
6. 自定义事件：`new Event('事件名')` 和 `new CustomeEvent('事件名', {})`（多了一个配置对象，控制是否可冒泡、是否可取消）
   * 实例用来触发事件，事件名用来注册事件；
   * ele.addEventListener('自定义事件名', () => {})，给元素注册自定义事件
   * this.dispatchEvent(自定义事件实例)，触发自定义事件（一般在原生事件里面执行，this就是DOM元素）
7. onload的执行时机
   * html解析完毕且页面中引用的外部资源全部加载完毕才执行onload
   * 而jQuery中的ready事件会在html解析完毕就执行
8. 页面局部刷新的方法
   * 对于vue项目，可以使用component组件，修改is参数
   * 准备不同的内容，控制其显示或隐藏
   * 使用ajax请求新的数据，处理后将其渲染的页面上

### CSS

1. css定位有哪几种

   * static、relative、absolute、fixed、sticky

2. css文字背景渐变怎么做

   * 1.使用background-image设置渐变，使用background-clip设置按文本裁切，文本颜色设为透明
   * 2.给文本一个起始颜色，然后使用伪元素覆盖文本；伪元素的content设置为attr(text)，文本颜色设置为终点颜色，设置mask为渐变色

   ```css
   /* clip */
   .text-gradient {
       background-image: linear-gradient(to right, orange, purple);
       -webkit-background-clip: text; /* IE不支持 */ 
       color: transparent;
       font-size: 30px;
   }
   /* mask */
   .text-gradient {
       position: relative;
       color: blue;
       font-size: 30px;
   }
   .text-gradient:before {
       content: attr(text);
       position: absolute;
       z-index: 10;
       color: orange;
       -webkit-mask: linear-gradient(to right, transparent, orange);
   }
   ```

3. 常用伪元素有哪一些？

   * ::before和::after

4. css如何清除浮动

   * overflow: hidden

   * ```css
     .clearfix::before,
     .clearfix::after{
         content: "";		/* 1.伪元素要设置内容才起作用 */
         display: block;		/* 2.伪元素默认为行内元素，不能设置高度 */
       	clear: both;		/* 3.清除左右两侧浮动 */
         height: 0;			/* 4.高度和行高设为0，不占位置 */
         line-height: 0px;
         visibility: hidden;	/* 5.设置为不可见 */
     }
     ```

5. CSS 中实现元素水平垂直居中的方式有哪些？

   1. 设置绝对定位，然后上下左右值设为0，margin为auto。
   2. 使用flex布局，justify-content:center，align-items:center。
   3. 绝对定位，设置left，top为50%，transform:translate(-50%，-50%)
   4. 子元素display:inline-block，再在父元素上text-aligen:center
   5. 设置文本的话，行高＋text-align

6. 弹性布局，一行三列，左右固定宽度，如何实现？

   * 浮动：第一个盒子`float: left;`，给宽度；第二个盒子`float: right;`，给宽度；第三个盒子自然就顶上去了，而且宽度等于父级，但内容会从浮动盒子边缘开始排列
   * 定位：三个盒子都给绝对定位；左侧`left: 0`，给宽度；右侧`right: 0`，给宽度；中间只给left和right，不给宽度；
   * table：父级`display: table;`；子级全部`display: table-cell;`；两侧子级给宽度；中间不给宽度；
   * flex：父级`display: flex;`；两侧子级给宽度；中间`flex: 1;`
   * grid：父级`display:grid; grid-template-columns: 300px auto 300px; grid-template-rows: 100px;`

7. Flex：1 包含哪三种属性
   * flex-grow: 1;（剩余空间的分配比例，0为不参与分配）
   * flex-shrink: 1;（超出部分的缩小比例，决定超出部分在每一个元素上的缩小量，0为不参与缩小）
   * flex-basis: 0%;（分配宽度之前的宽度，优先级高于width）

8. 什么是css盒模型
   * 解答：标准模型和IE模型
     * 标准模型：content-box
     * IE模型：border-box
     * 区别：宽高的计算方式不同

9. 如何解决上下margin重叠
   * 创建BFC

10. 什么是BFC
   * 就是 块级格式化上下文，是一块独立的渲染区域，它内部的元素不会与外部元素相互影响

11. BFC的特性（原理/渲染规则）是什么
    * 不同的BFC盒子的上下margin不会重叠，而同一个BFC内部的盒子的上下margin会重叠
    * BFC区域不会与浮动元素重叠
    * BFC区域会计算其内部的浮动元素的高度
    * 其他：独立渲染区域；子元素垂直排列；

12. 如何创建BFC
    * float不为none
    * 定位不为static、relative
    * display属性为：inline-block、table-caption、table-cell、flex或inline-flex
    * overflow属性不为visible

13. BFC的使用场景
   * 解决上下margin重叠（合并）
   * 清除浮动
   * 左右布局

14. 怎样阻止一个元素的鼠标事件
   * pointer-events: none;

15. 元素变形 transform

   * 平移：translate
   * 缩放：scale
   * 旋转：rotate
   * 倾斜：skew

16. 动画

   * 创建动画：`@keyframes car { //... }`
   * 使用动画：`animation: 动画名称 动画时间 运动曲线  何时开始  播放次数  是否反方向;`（可以用逗号写多组）

### Vue

1. vue的双向绑定原理是什么？里面的关键点在哪里？

   * 双向绑定（响应式）原理就是对数据的存取操作进行劫持，关键点在Object.defineProperty()这个方法
   * Dep：利用闭包，每一个属性都有一个Dep保存它的订阅者Watcher
   * Watcher：观察者，包含渲染方法，可以在初始化和依赖更新后 渲染页面内容

2. Vue的生命周期有哪一些？说一下它们每个阶段做什么操作？（非标准答案）

   | vue2            | vue3                | 作用                                                         |
   | --------------- | ------------------- | ------------------------------------------------------------ |
   | beforeCreate()  |                     |                                                              |
   | created()       |                     |                                                              |
   | beforeMount()   | onBeforeMount()     |                                                              |
   | mounted()       | onMounted()         |                                                              |
   | beforeUpdate()  | onBeforeUpdate()    |                                                              |
   | updated()       | onUpdated()         |                                                              |
   | beforeDestroy() | onBeforeUnmount()   |                                                              |
   | destroyed()     | onUnmounted()       |                                                              |
   | activated()     | onActivated()       |                                                              |
   | deactivated()   | onDeactivated()     |                                                              |
   |                 | onRenderTracked()   | 注册一个调试钩子，当组件渲染过程中追踪到响应式依赖时调用。会给出被追踪的对象和数据对应的key |
   |                 | onRenderTriggered() | 注册一个调试钩子，当响应式依赖的变更触发了组件渲染时调用。会给出被追踪的对象、数据对应的key、旧值和新值 |
   |                 | onErrorCaptured()   |                                                              |

3. 组件通讯方式有哪一些？

   * props、自定义事件；eventBus；vuex；$parent；provide/inject；路由参数；

4. 页面之间通信的方式

   * 路由传递参数
   * vuex
   * sessionStorage

5. Vuex有几个属性及作用？

   * state：状态，就是保存响应式数据的地方
   * getter：获取状态，类似于计算属性
   * mutation：更改状态
   * action：通过提交mutation来更改状态，可进行异步操作
   * module：模块，代码分割

6. Vue的监听属性和计算属性有什么区别？

   * watch的作用是监听状态的变化，然后进行某种操作，比如操作DOM，发送请求等
   * computed的作用是对状态进行某种处理，得到一个计算结果并缓存

7. Vue的导航守卫有哪一些？

   * beforeRouteLeave
   * beforeEach
   * beforeRouteUpdate
   * beforeEnter
   * beforeRouteEnter
   * beforeResolve
   * afterEach

8. Vue2.0和vue3.0有什么区别？

   * 实现数据劫持的方式不同：vue2使用的是defineProperty；vue3使用的是proxy
   * 组件的写法不同：vue2主要使用选项式api，逻辑割裂比较严重；vue3可选用组合式api，逻辑更加清晰分明
   * 模板根元素：vue2必须有个一唯一的根元素；vue3则没有这个限制
   * 数组元素的监听：vue2无法监听到数组元素的变化；vue3可以

9. Vue常用的指令有哪些？

   * v-if、v-for、v-show、v-on、v-bind、v-model、v-slot、v-text、v-html、v-pre、v-cloak、v-once等

10. v-If和v-show有什么区别？

   * v-if决定是否渲染；v-show决定是否显示（渲染了）

11. ==v-for为什么要加一个key？==

   * 这个跟diff算法有关，diff算法会对新旧虚拟DOM树的同级节点进行比较；
     * 比较过程中存在4个指针，分别指向新旧虚拟DOM的头尾元素，这4个元素两两进行比较，如有匹配，则在真实DOM中 把对应的旧指针的DOM元素移动到新指针的位置上去；
     * 如果没有匹配，则看是否有key，没有key的话，就会直接新建一个DOM元素插入；有key的话，会根据这个key生成的map在旧的虚拟DOM中查找，如果找到了就复用对应的真实DOM，没找到则新建DOM元素
     * 所以key的作用是尽可能的提高列表更新时的已有元素利用效率
   * vue在更新列表的时候，默认会采取“就地复用”的原则，这样会导致在列表中插入一条数据后，插入位置后面的所有元素都要向后移动；而有key的话，具有相同的key的原有元素会复用，只需要新插入一个元素就行了

12. 你是如何封装一个组件的？

    * 先根据它的功能想好结构，然后分析它需要传入什么参数，要抛出什么事件，如何处理传入的参数，需要什么初始化数据；先把主要流程完成，然后调试细节逐步完善
    * 例子：经纬度输入组件、简单增删改查组件，el-table二次封装

13. canvas的1次使用经验

    * 环状流程图

14. keep-alive是什么？有哪几个生命周期阶段？

    * vue提供的对组件进行缓存的组件，被包裹在其中的组件，相较于普通组件：
    * 多出两个生命周期：activated、deactivated，而beforeDestroy、destoryed则不会触发
    * 当引入keep-alive的时候，页面第一次进入，钩子的触发顺序created-> mounted-> activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated。

15. 父子组件生命周期执行顺序是怎么样的？

    * 初始化：父beforecreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted
    * 子组件更新：父beforeUpdate ->子beforeUpdate -> 子updated -> 父updated
    * 父组件更新：不影响子组件
    * 销毁：父beforeDestroy ->子beforeDestroy -> 子destroyed -> 父destroyed

16. mixins执行顺序和选项覆盖情况？

    * 对于data定义属性：组件中定义属性覆盖mixins中同名字段
    * methods方法：组件内的方法覆盖mixins中的方法
    * computed：组件的computed属性覆盖mixins内的computed属性
    * 生命周期：先mixins（按mixins中顺序），再组件
    * 相同的watch监听：mixins中的watch监听先执行

17. vue-cli > vite

    * 导入类型必须加type, import type
    * vite没有提供node模块，需要引入插件或自己实现相应功能
    * 动态生成路由
      * import.meta.glob('../views/*\*/\*.vue')得到views目录下的所有vue文件(对象：相对路径: () => import(组件))
      * 在替换路由表的component的时候，就可以根据路径得到相应的异步路由组件(() => import(组件))
    * ts文件中导入vue文件报找不到类型错误
      * vite是在env.d.ts中写.vue文件的模块声明文件
      * vue-cli是在src/shims-vue.d.ts中写

18. MVVM是什么

    * MVVM是一种**设计思想**，它是`Model-View-ViewModel`的缩写
    * `Model`是代表**数据模型**，也可以在`Model`中定义数据修改和操作的业务逻辑。
    * `View`是代表**UI组件**，它负责将数据模型转化成UI展现出来。
    * `ViewModel`是一个同步View和Model的对象。
    * 在MVVM框架下，`View`和`Model`之间并没有直接联系，而是通过`ViewModel`（桥梁）进行交互。`Model`和`ViewModel`之间的交互是**双向**的。`ViewModel`通过双向数据绑定将`View`和`Model`层连接了起来，而`View`和`Model`之间的同步工作都是完全自动的，无需人为操作。

19. vue路由的mode

    * hash：利用hash变化不会刷新页面。并监听hash变化实现路由
    * history：利用HTML5 pushState API实现路由

### 浏览器

1. 本地存储有哪一些？他们三者有什么区别？
   * cookie、sessionStorage、localStorage
   * 1.存储⼤⼩：cookie数据⼤⼩不能超过4k，sessionStorage和localStorage可以达到5M或者更⼤
     2.有效时间：localStorage存储持久数据，浏览器关闭后数据不丢失除⾮主动删除数据；sessionStorage数据在当前浏览器窗⼝关闭后⾃动删除；cookie设置的cookie过期时间之前⼀直有效，即使窗⼝或浏览器关闭
     3.数据与服务器之间的交互⽅式：cookie的数据会⾃动的传递到服务器，服务器端也可以写cookie到客户端；sessionStorage和localStorage不会⾃动把数据发给服务器，仅在本地保存

2. 浏览器中输入url后的流程

   * 浏览器解析域名得到服务器ip地址
   * ==TCP三次握手建立客户端和服务器的连接==
   * 客户端发送HTTP请求获取服务器端的静态资源
   * 服务器发送HTTP响应报文给客户端，客户端获取到页面静态资源
   * ==浏览器解析文档资源并渲染页面==
   * ==TCP四次挥手关闭客户端和服务器的连接==

3. 简述一下DNS解析的过程

   * 依次查找浏览器缓存、操作系统缓存、路由器缓存，没找到继续
   * 查询本地域名服务器，如果也没找到，则开始迭代查询
   * 由本地域名服务器询问根域名服务器，根域名服务器告诉它应该去哪个顶级域名服务器查询
   * 本地域名服务器询问那个顶级域名服务器，顶级域名服务器告诉它应该去哪个二级域名服务器查询
   * 本地域名服务器询问那个二级域名服务器，......重复这个迭代过程，直至找到域名对应的ip地址
   * 本地域名服务器把这个域名与ip地址的对应关系 写入自身缓存，并把这个结果返回给浏览器

4. 简述一下TCP三报文握手的过程

   * 客户端向服务器发送同步报文，**SYN=1** ，**seq=x** —— **syn-send（同步已发送）**
   * 服务器收到后向客户端发送响应报文，**SYN=1**，**ACK=1**，**seq=y**，**ack=x+1**—— **syn-rcvd（同步收到）**
   * 客户端收到后发送确认报文，**ACK=1**，**seq=x+1**，**ack=y+1**—— **established（已建立连接）**
   * 服务器收到—— established（已建立连接）

5. 简述一下TCP四次挥手——假设客户端发起挥手

   * 客户端向服务器发出连接释放报文，**FIN=1**，**seq=u** —— **FIN-WAIT-1（终止等待1）**
   * 服务器收到，立即发出确认报文，**ACK=1**，**seq=v**，**ack=u+1** —— **CLOSE-WAIT（关闭等待）**
     * 此时从客户端到服务器这个方向的连接就释放了，而服务器还可以继续向客户端发送数据。客户端收到确认报文后进入**FIN-WAIT-2（终止等待2）**
   * 服务器数据发送完毕后，向客户端发出连接释放报文，**FIN=1**，**ACK=1**，**seq=w**，**ack=u+1**—— **LAST-ACK（最后确认）**
   * 客户端收到，要发出确认报文，**ACK=1**，**seq=u+1**，**ack=w+1**—— **TIME-WAIT（时间等待）**
     * 客户端**等待2MSL**（2x最长报文段寿命）后释放连接

6. TCP连接和释放过程中的标志位

   * SYN：同步位
   * seq：序号
   * ACK：确认位
   * ack：确认号
   * FIN：终止控制位

7. TCP为什么需要3次握手，而不是两次

   * 为了防止已失效的连接请求报文突然又到达服务器，如果没有第三次握手，这个报文过了好长一段时间后到达服务器，服务器发出确认，就建立了一个连接

8. TCP4次挥手为什么最后要等待一段时间 

   * 1.确保服务器收到确认报文（如果没收到，服务器会超时重传释放报文）；
   * 2.等待本次连接的所有报文都从网络中消失，避免已失效的连接请求报文干扰下次连接建立；

9. 异步加载

   * 页面解析 和 资源加载是可以同时进行的；
   * 但 页面解析（其实也是js执行） 和 js执行不能同时进行

   * 异步加载方式：

     * 动态脚本加载
       * 就是当需要某个功能时，动态地向页面中插入1个script标签，来请求相应功能的js代码并执行

     * defer：script标签的一个属性`<script defer></script>`
       * 添加了defer的script会在HTML解析完毕再执行，且会保证执行顺序

     * async：script标签的一个属性`<script async></script>`（仅适用于外部脚本，即通过src加载的脚本）
       * js脚本加载完毕就会立即执行（页面解析会暂停），不会保证执行顺序，即谁先加载完谁先执行

10. 浏览器渲染过程

   * 浏览器解析html结构，生成DOM树；解析css生成 css规则树
     * `DOM` 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。
   * 根据DOM树和css规则树，构建render tree（渲染树）
     * `Rendering Tree` 渲染树并不等同于 DOM 树，因为一些像 `head` 或 `display:none` 的东西就没必要放在渲染树中了。
   * Layout：根据render tree（已知结构和样式）计算元素的大小、位置 等
   * 最后开始绘制 页面
   * 上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

11. 什么是重排/回流

    * Reflow：重排。只要元素发生的变化（大小、位置等）影响到了布局，就会引起重排Reflow（可能是局部也可能是整个页面）
      * 比重绘Repaint更耗费性能
    * 常见的Reflow的原因
      * *页面第一次渲染时*
      * 操作DOM时（添加、修改、删除元素）
      * 某些元素的尺寸变化了
      * CSS的布局属性变化了

12. 什么是重绘

    * 如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。
      * 性能消耗比Reflow小一些
    * 常见的Repaint的原因
      * DOM改动（不影响布局的前提下）
      * CSS改动（不影响布局的前提下）

13. 回流和重绘

    回流（reflow，也叫重排、布局）：某部分的变化影响了布局，浏览器需要重新渲染。（如元素大小、位置的改变）

    重绘（repaint）：元素的某一部分发生改变，尺寸、位置没有改变。（字体颜色、背景颜色的改变）

14. 引起回流的几个主要原因：

    （1）网页初始化

    （2）JS操作DOM树（增加、删除元素等）

    （3）某些元素的尺寸改变

    （4）CSS属性的改变

    浏览器的“dirty”系统：

    为了避免页面细小的改变就引起回流和重绘，“dirty”系统会将这些改变操作积攒一批再进行操作，这又叫异步reflow或者增量异步reflow。有些特殊情况不会这么做：resize窗口、改变了页面默认的字体等，这些操作会直接触发回流。

15. 编写代码时如何减少回流和重绘：

    （1）修改样式不要逐条修改，定义CSS样式的class，直接修改元素的className

    （2）不要将DOM节点的属性值放在循环中当成循环的变量

    （3）为动画的HTML元素使用fixed或absolute的position属性，修改它们的CSS就不会触发reflow

    （4）把DOM离线后修改，设置display：none或者clone元素到内存中，修改完成再显示回页面

    （5）不要使用table布局，一个微小的改变就可能引起整个table的重新布局

### 前后端通信

1. 什么是同源策略 及 限制

   * 同源策略：同源指的是 url中协议、域名、端口都一致。三者只要有1个不一致，就是跨域，浏览器会阻止跨域通信（出于安全考虑）
   * 限制：
     * cookie、localStorage、*indexDB*无法读取
     * DOM无法获得
     * AJAX请求不能发送

2. Ajax请求的基本流程

   * 1.创建XMLHttpRequest对象，需要处理兼容性（window上不存在XMLHttpRequest，就使用ActiveXObject）
     * 1.1把参数拼接成字符串，如果是get请求，则拼接到url后面，如果是post请求则作为xhr.send()的参数
   * 2.调用xhr.open('get', url, true)方法，准备发送请求
   * 3.调用xhr.send(post参数)方法，执行发送
   * 4.注册onreadystatechange事件（xhr.readyState有5个值：0：xhr创建；1：请求已发送；2：收到了响应；3：正在解析数据；4：数据解析完成可用）当以上值变化时，就会触发readystatechange事件（0=>1不会）
     * 在readystatechange事件的回调中，检查xhr.readyState和xhr.status，并处理xhr.responseText

3. xhr原生请求同步获取js文件内容

   * xhr.open('GET', 'js文件路径', false)
   * onreadystatechange中，this.responseText就是代码内容
   * 然后创建script，令script.text=js内容

4. 跨域通信的几种方式

   * jsonp：利用script标签可以跨域请求脚本的特性，前端定义好一个回调函数，服务器返回调用这个函数的代码和数据，作为js脚本执行
     * 优点：兼容性好
     * 缺点：只能处理get请求
   * Hash
   * postMessage
   * WebSocket
   * CORS

5. postMessage的使用

   * 发送方使用目标页面的window调用postMessage API，传入消息、可以接收消息的源
     - `Window.open(url)` （生成一个新窗口然后引用它的window），
     - `Window.frames[n]` (索引值，第n个iframe的window)。（获取内嵌iframe窗口的window）
       * 由于父页面window.frames === window（父页面自己），所以还可以使用window[n]
     - `Window.opener` （产生这个的窗口的页面的window，即使页面刷新也能获取到），
     - `Window.parent`（`<iframe>`内嵌窗口的的父页面的window）
       * *iframe的window.parent === 父页面的window，对于父页面window.parent就是它自己，子页面的window.parent就是它的父页面的window对象*
   * 接收方注册message事件，可从event上获取数据（event.data）、发送方window（event.source）、发送方所属源（event.origin）

6. WebSocket的使用

   * WebSocket是一种应用层协议，在url中使用ws 或 wss（加密）来表示
   * 特点：

     * ws最大的特点是：服务器可以向客户端推送消息（http协议不能）
     * 没有同源限制，客户端可以与任意服务器通信。

   * 四个事件：onopen、onclose、onmessage、onerror

   * 心跳检测

     * 设置心跳定时器发送心跳信号
     * 发送完心跳信号，就立即设置超时定时器，等待检查服务器响应状态
     * 如果有状态，则再次设置心跳定时器发送心跳信号；否则开始重新连接

   * 事件订阅与发布

     ```js
     {
         'event1': [cb1, cb2, ...],
         'event2': [cb3, cb4, ...]
     }
     ```

     * eventBus.on('event1', cb1)：添加订阅
     * eventBus.emit('event1')： 发布事件

7. CORS是什么

   * 跨域资源共享；需要浏览器（除了IE10以前的都支持）与服务器都支持
   * 过程
     * *对于请求方法是HEAD、POST、GET且只有限几个header字段的请求*，==支持CORS的浏览器会直接发送请求，只不过会在头部加一个origin字段，表示发起请求的 源==
     * ==如果origin指定的源，在服务器允许访问的范围内，服务器就返回正常的响应==
       * 响应包含Access-Control-Allow-Origin字段
     * ==否则服务器会告诉浏览器不允许跨域==。*如果响应没有上述字段，则浏览器会抛出一个错误*

8. 通过hash跨域
   * 修改iframe标签的src中的hash；在iframe页面中监听onhashchange事件
9. nginx代理
   * nginx模拟一个虚拟服务器，因为服务器与服务器之间是不存在跨域的，
   * 发送数据时 ，客户端->nginx->服务端
   * 返回数据时，服务端->nginx->客户端



### 协议

1. http协议的主要特点

   * 简单快速：每一个资源的URI（统一资源标志符，URL是它的子集；URL是绝对的，URI可以是绝对的，也可以是相对的）都是固定的，只要根据资源的唯一标识符，就可以访问这个资源
   * 灵活：体现在：不同的数据类型都可以通过http协议传输（http报文的头部有一个数据类型字段）
   * 无连接：1次任务结束，它就会断掉，不会保持连接；
     * http/1.1提供了持续连接的功能，使得服务器发送响应后依然保持1段时间的连接（http/1.0没有）
   * 无状态：由于http是无连接的，服务端无法区分两次连接的客户端是否为同一个身份

2. http报文的组成部分

   * 请求报文：
     * 请求行：方法，资源URL，http版本
     * 请求头：一些键值对（主机名、是否保持连接、客户端信息等）
     * 空行：
     * 请求体：
   * 响应报文：
     * 状态行：http版本，状态码，短语（状态描述符）
     * 响应头：一些键值对
     * 空行：
     * 响应体：资源主体

3. http方法

   * GET：获取资源
   * POST：传输资源（添加信息）
   * PUT：更新资源（储存文档）
   * DELETE：删除资源
   * HEAD：获得报文头部

4. GET和POST的区别

   * *GET在浏览器回退中是无害的，而POST会再次提交请求*
   * 缓存：GET请求会被浏览器主动缓存，而POST不会（除非手动设置）
   * 历史：GET请求参数会完整地保存在浏览器的历史记录里，而POST请求不会
   * 参数长度：GET在请求过程中参数长度是有限制的，而POST没有限制
   * 参数传递方式：GET参数通过url传递，而POST参数通过Request body传递
     * 所以GET比POST更不安全
   * post传参发送两个请求包，一个是请求头，一个是请求体，请求头发送后服务器进行验证，要是验证通过的话就会给客户端发送一个100-continue的状态码，然后就会发送请求体

5. http状态码

   * 1xx：表示请求已收到，继续处理
   * 2xx：请求成功
     * **200：客户端请求成功**
     * **206：请求某个资源的一部分，服务器完成了这个请求（即响应了这部分内容，例如视频）**
   * 3xx：重定向，请求必须进行更进一步的操作
     * 301：所请求的页面已经转移至新的url（了解）
     * 302：所请求的页面已经==临时==转移至新的url（了解）
     * **304：客户端有缓存的资源，可以使用缓存的资源**
   * 4xx：客户端错误，语法错误或请求无法实现
     * **400：客户端的请求有语法错误，不能被服务器所理解**
     * 401：请求未经授权（了解）
     * **403：请求访问的页面 被禁止访问**
     * **404：资源不存在**
   * 5xx：服务器错误，服务器未能实现合法的请求
     * 500：服务器发生不可预期的错误，原来缓冲的文档还可以继续使用（了解）
     * 503：请求未完成，服务器过载或宕机，一段时间后可能恢复（了解）

6. 什么是持久连接

   * http/1.0是非持久链接，每进行1次http请求，都要花费资源去建立链接，这样对于连续的请求效率就很低
   * http/1.1支持持久连接，一次请求响应后，连接不会立即被释放，而是等待一段时间再释放

7. 什么是管线化（其实就是流水线方式）

   * 持续连接有 流水线方式 和 非流水线方式
   * 就是对于连续的请求，第一个请求发出后，就可以发出第二个请求，而不必等待第一个请求的响应回来后再发起第二次请求（这样做提高了效率）
   * 特点：
     * 一：因为流水线依赖 持续连接，所以http/1.1才支持
     * 方：只有GET和HEAD请求可以以流水线方式请求，*POST则有所限制*
     * 初：初次连接是不会启动 流水线机制，因为服务器不一定支持
     * 顺：流水线方式不会影响响应的顺序

8. http2：多路复用，头部压缩，服务器推送

   * 多路复用：http/2 以帧为单位在一个tcp连接中发送数据，这些帧是无序的，可以并行发送，响应也不需要依赖顺序（不阻塞）

9. http和https的区别：

   * 1、证书：https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

     2、安全：http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

     3、端口：http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

     4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

10. 

### 业务

1. 你的登录拦截怎么实现的？
   * 在axios的响应拦截器（`service.interceptors.response.use`）中检查接口响应数据，如果服务器返回未登录状态，就清理过期的用户信息（roles、permissions、token）然后跳转到首页
   * 在beforeEach路由守卫中，检查token是否存在，如果token不存在，则跳转到登录页

2. 登录
   * action里面调用登录接口, 用密码获取token
   * 然后就跳转到退出时的路由(保存在本地存储，如果没有，就跳到首页)
   * 在路由前置守卫中调用action获取用户信息
   * 根据用户信息里的role再调用接口获取用户的路由信息，根据路由生成路由表，解析后，加到router里面。最后调用next传入本来要去的页面的路由对象

3. 有用过图表吗？用的多吗？
   * 用过echarts，封装过一个通用图表组件：传入配置对象、原始数据、处理原始数据的函数，内置了resize

4. 有自己从0到1搭建过项目吗？
   * 大型项目做过系统拆分优化
   * 将物流平台拆分为 物流门户、物流环节、物流态势三个项目，主要的难点在于菜单的跳转
   * 解决菜单的问题：
     * 做了一个子系统信息维护页面，用于维护子系统的名称、地址、appid、所属组
     * 在菜单维护页面为子系统添加菜单时，必须选择所属组，而appid则在前端配置文件中配置
     * 除物流门户外的子系统在请求路由表的时候，带上自己的appid和所属组id，接口就只返回它本身的路由表
     * 对于物流门户，接口会返回所有的路由表，此时菜单分为3种情况：门户系统自身的菜单、其他子系统的菜单、外链。对于自身的路由，直接$router.push；对于外链直接打开；对于其他子系统的菜单，要根据其id在菜单树中找到对应的节点的路径，拼出完整的路由，再拼上它的地址，形成完整的链接跳转过去

5. 关于前端权限的设计

   * 使用v-hasPermi指令设置某个元素/组件的权限字符，例如v-hasPermi="['sys:edit:menu']"（数组内部就是权限字符），指令的实现可以参考ruoyi
   * 在后台菜单管理页面，给相应的菜单配置权限字符
   * 在后台角色管理页面，给角色分配菜单权限(菜单有对应的权限字符，这样使用这些角色的用户就获得了相应的权限字符集)
   * 在用户管理里面给用户分配角色(用户就获得了指定角色的权限)
   * 登录成功后调用获取用户信息接口。拿到权限列表(属于中的每一项都是一段权限字符)
   * v-hasPermi指令就是对比当前元素的权限字符是否存在于用户权限列表中，如果不存在，也移除相应的元素

6. 28单点登录

   * 关键参数：

     * loginUrl：单点登录统一认证服务登录页面地址"http://ssoserver.com/sso/login?redirectUrl="
     * baseUrl：client后端接口地址"http://abc.com/base/"
       * loginApi：client验证登录的后端接口"/user/current"
       * 可选参数：`{service: 'client页面地址', code: '单点登录页获取到的code'}`，用于从单点登录页面返回到client时
     * logoutUrl： 单点登录统一认证服务退出登录地址"http://ssoserver.com/sso"
       * logoutApi：单点登录统一认证服务退出登录接口"/logout"
     * 使用fetch调用接口（"http://abc.com/base/user/current"），通过`credentials: 'include'`配置请求在跨域时带上cookie

     进入client页面，进入路由前置守卫，进入单点登录流程

     1. 路由前置守卫，直接进入单点流程：
        * 检查url中有没有code参数（地址栏输入url）
          * 没有（地址栏输入url）：调用"http://abc.com/base/user/current"（baseUrl + loginApi），没带code肯定返回未登录状态
            * 去单点登录页面loginUrl，带上返回地址："http://ssosever.com/sso/login?redirectUrl=client页面地址"
            * *在单点登录页输入账号密码进行登录，登录接口会拿到code，然后code被拼接到返回的 url中，然后跳转到client页面，然后在client页面进行下面的步骤*
          * 有（单点页面回来的/其他系统跳过来的）：（注意：这里的路由守卫已经不是之前的路由守卫，因为页面已经刷新，不过代码逻辑一样）
            * 调用"http://abc.com/base/user/current?service=client页面地址&code=code字符串"（baseUrl + loginApi + ?query）验证code
            * code有效：登录成功（cookie已自动保存，包含sessionid和utoken），则继续完成路由（如果没有获取用户信息和菜单信息，则先进行获取）（或强制刷新页面——项目中解决sso-login库的反复刷新问题）
            * code无效：没有登录，则去单点登录页
     2. 接口响应拦截器发现凭证失效（sessionid和utoken），接口请求失败
        * 调用"http://ssoserver.com/sso/logout"（logoutUrl + logoutApi）通知单点认证服务退出，然后去单点登录页loginUrl

7. 国网单点方案

   进入client页面，进入路由前置守卫，检查token

   1. 路由前置守卫：
      * 检查有没有token，有则继续完成路由（如果没有获取用户信息和菜单信息，则先进行获取）；
      * 没有token则检查url中是否存在access_token（参数/hash）
        * 没有access_token，说明刚刚输入url，则跳转到单点登录页面（在跳转url中通过参数带上当前地址，以便返回）
          * *在单点登录页面输入账号密码进行登录，登录接口会拿到access_token，然后access_token被拼接到返回的url中，然后跳转到client页面，然后在client页面进行下面的步骤*
        * 有accesss_token，说明刚刚从单点页面完成登录跳转回来（注意：这里的路由守卫已经不是之前的路由守卫，因为页面已经刷新，不过代码逻辑一样）
          * 拿着access_token调用登录接口（换取token）
          * 成功则继续完成路由（如果没有获取用户信息和菜单信息，则先进行获取）
          * 失败则调用退出登录接口，前往默认页面（例如'/'），然后会进入路由前置守卫，重新进行登录流程
   2. 接口响应拦截器发现token失效
      * 直接跳转到默认页面或（非单点）登录页面，然后会进入路由前置守卫，重新进行登录流程

8. webGis使用过哪些功能

   * 散点图、热力图、军标标绘、地图上的事件、在地图上绘制路径、通过地图取经纬度、定位和缩放等

9. 



### 移动端

1. 移动端如何适配不同屏幕尺寸？
   * 利用rem（稿件宽度/稿件1rem的宽度 = 屏幕宽度/屏幕1rem的宽度(就是根元素字体大小)）；利用媒体查询
2. 

### 小程序

1. 如何实现小程序的request封装及拦截？
   * 在一个js文件中定义并导出一个函数，这个函数返回一个promise，这个promise中执行uni.request()，在success回调中判断后台返回的状态，调用reject或resolve，在fail回调中调用reject

2. 小程序微信登录流程

   * 在登录页中，onload生命周期，调用wx.login()，获取code，获取到的信息如下：

     * wx.login()获取登录凭证（code）。通过凭证进而换取用户登录态信息
     * 用户登录态信息：包括用户在当前小程序的唯一标识（openid）、微信开放平台帐号下的唯一标识（unionid，若当前小程序已绑定到微信开放平台帐号）及本次登录的会话密钥（session_key）等。

     ```
     {
     	code: "081Wcw000lI7GL1SE2300Qftk93Wcw07"
         errMsg: "login:ok"
     }
     ```

   * 用户点击 微信授权button（uniapp的button自带open-type类型选型）， 在（getuserinfo事件的）回调中调用wx.getUserInfo()，获取用户信息拿到 加密的用户信息，success回调可以获得如下信息：

     * 可以通过button的withCredentials来指定是否带上登录态信息。
     * encryptedData：加密的用户信息 字符串
     * iv：加密算法的初始向量

     ```
     {
     	encryptedData: "m2N2+81J7BvILDOcB6m/+n7aDAdgOppyI3ltIEaNlg6hKqd6wnpHX2bq5EcL5hIpC/kV1+8jD3jFVSZSubVWCVTPCWtXblYM05+krNRciHB47ff/yh2l/A6B5qC57B5NpAJnhBgQvCES5x9cR930NtosVYwffecb3DNp5jg93VMRQCTjgVhpV0mmkm476k+Mt7xs0l9UJucLZvRyV/L5BvfluCVAFGQL2lWvyQg+ujxvuMYoFLV0NyQTyIeWQBGYqELrnn7ze15EjKd2oF2jHBto91ucuZLF+9UzJL+VqhXlEBKulO4IAioG3rGoj0QpFLc/x8myqY3ayyGh9KNljUZ2MnkJz13XTXTZM3+pyBKcQQyS9Dx8Pf8IqBFinc01NLqoSvfgOVLGPZOtIPag2xqQiwRjHS6QXDGEG32bYs+ZTDEHKKB0XJSL5VDrm9yaaxCHTuLr+bb36GwZj+brYA==",
     	errMsg: "getUserInfo:ok",
     	iv: "FFUBUbnruEB/SCbmWS+6BQ==",
     	rawData: { 这里是有内容的，不过字段都是"" },
     	signature: "f5a0b57a8a9fc4fa4fd999201ec215f520af5841",
     	userInfo: { 这里是有内容的，不过字段都是"" },
     }
     ```

   * 使用拿到的 {用户登录凭证，加密的用户信息，加密算法的初始向量}，向后端api请求登录（项目中是在src/store/user.js中进行的），*这里后端拿到登录凭证后会向微信平台请求一些数据*。

     * 如果登录成功 小程序客户端 会获得（后端返回的） 自定义的登录状态信息，把这些信息保存在vuex中的userinfo
     * 并把上述信息中的token保存到本地存储，后续每次ajax请求，都要带上token
     * 如果后端返回的结果表示 登录失效，则删除token，并提醒用户重新登录

3. 登录过程涉及的信息

   * 客户端发起登录阶段：

     * 获取code：小程序登录凭证，（前端）通过wx.login()获取；用途：向后端请求登录时要用到
       * 开发者应该在明确需要重新登录时才调用 wx.login，因为调用wx.login可能会导致session_key失效
       * 所以应该只在登录页调用wx.login，只有后端告诉 我前端 登录失效了（或第一次登录）才去登录页
     * 获取encryptedData：当前微信用户信息（包含一些敏感信息）的加密字符串，（前端）wx.getUserProfile()获取；用途：告诉后端，用户信息是什么（加密）。此信息只有后端能解密
     * 获取iv：用于解密上述加密信息的 初始向量，（前端）wx.getUserProfile()获取
     * 获取其他：rawData是用于计算签名signture的，signture数据签名，用于验证（了解）

   * 向后端请求登录阶段：

     * 请求后台接口，把code（必须）和encryptedData、iv等信息发送给后端（看需要）

     * 后端拿到code（还有encryptedData、iv等）后，通过微信提供的接口，向微信服务器发起请求：

       * 请求参数：

         * appid：小程序 的标识，一个小程序1个，由开发者申请
         * appsecret：小程序秘钥，由开发者申请
         * code：就是上文的code

       * 获得的数据：

         * openid：**用户唯一标识**

         * session_key：用户数据进行加密签名的密钥。为了应用自身的数据安全，开发者服务器**不应该把会话密钥下发到小程序，也不应该对外提供这个密钥**。

           ```json
           {
           	"session_key":"mFaVU6h14PwNLS+XwWLlwg==",
           	"openid":"oGAee6ta9QvcHGd2mDOuvHpWl4JM"
           } 
           ```

       * 后端使用 session_key、appid、encryptedData、iv 对加密的用户信息进行解密，得到：

         ```json
         {
             "openId": "OPENID",	// 微信用户在当前小程序的唯一标识
             "nickName": "NICKNAME",	// 微信昵称
             "gender": GENDER,	// 性别
             "city": "CITY",		// 城市
             "province": "PROVINCE",	// 省
             "country": "COUNTRY",	// 国家
             "avatarUrl": "AVATARURL",	// 头像
             "unionId": "UNIONID",	// 微信用户在当前公众号 小程序 等端的通用唯一标识
             "watermark":
             {
                 "appid":"APPID",	
                 "timestamp":TIMESTAMP
             }
         }
         ```

       * 后端根据以上信息，自定义一个userinfo，可能包括 基本信息（openid，token等）把这个信息交给前端

   * 前端拿到 用户信息（后端自定义的）之后：

     * 登录成功：把用户信息保存起来（到vuex），然后把token保存到本地存储中；之后每次请求都带上token（header），如果后端token失效（根据状态码），则在响应拦截中 跳转到登录页，重新进行登录流程
     * 登录失败：则提示用户登录失败，用户可以点击授权，重新登录

4. 小程序微信支付

   * 将要充值的金额通过接口给后端，后台调用微信支付的接口生成预支付单，后台拿到预付单标识生成带签名的支付信息
   * 后台将支付参数返回给前端：随机字符串和预付单id
   * 前端根据 AppId、时间戳、随机字符串、预付单id、签名类型（MD5）、商户key 生成签名（MD5）
   * 前端使用 时间戳、随机字符串、预付单id、签名类型（MD5）、签名，调用 wx.requestPayment(data)，拉起微信支付，支付结果可以通过data中的 success/fail 回调来获取

5. 小程序消息推送

   * 在管理后台申请消息模板
   * 调用wx.requestSubscribeMessage传入要向用户申请的消息模板tmplIds
   * 微信返回成功后，在success回调中调用接口通知后台允许发送通知

6. 小程序的生命周期

   * onLaunch、onShow、onHide、onError

7. 小程序页面的生命周期

   * onLoad、onShow，将初始数据给渲染线程
   * 渲染线程初次渲染，完毕后通知逻辑线程onReady
   * 页面隐藏触发onHide，页面显示触发onShow，页面销毁触发onUnload

### echarts

1. 简单图表实例

   ```js
   option = {
     xAxis: {
       type: 'category',
       data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
     },
     yAxis: {
       type: 'value'
     },
     series: [
       {
         data: [150, 230, 224, 218, 135, 147, 260],
         type: 'line'
       }
     ]
   };
   ```

2. 项目中使用过哪些图表

   * 折线图、柱状图、饼图、散点图、地图、雷达图、热力图

3. dataset数据集怎么用

   * 设置dataset选项，主要包括数据集的维度、内容，维度可以看成表头；在series中可以指定 取哪个数据集的数据，坐标轴取哪个维度的数据
   * 可以通过transform对dataset进行处理，比如`type: 'sort'`（在dataset数组中与数据集对象平级，也是一个对象）

4. 富文本怎么用

   * 对于文本可以使用formatter对文本进行格式化，在返回的字符串中使用 花括号把要自定义样式的内容包裹，竖线左侧是自定义的样式名称，右侧是文本内容；然后在rich属性中定义样式的具体属性。（`{style1|文本}`）

### 附录

#### 1. postMessage

1. 基本用法

   * postMessage是Html5新增的 用于页面间通信的API，因为可以跨域（即两个页面的源不同也可以通信），所以可以作为跨域通信的一种解决方案
     * 父页面 与 iframe内嵌页面 的通信
     * 父页面 与 它所打开的页面 的通信
     * ==由于 targetWindow的限制，这个API是不能在任意两个页面之间通信的（获取不到对方的window）==
   * 基本语法：`targetWindow.postMessage（message，targetOrigin，[ transfer ]）;`
     * targetWindow：对将接收消息的窗口window对象的引用。获得此类引用的方法包括：
       - `Window.open(url)` （生成一个新窗口然后引用它的window），
       - `HTMLIFrameElement.contentWindow`（`<iframe>`内嵌窗口的window，`HTMLIFrameElement是iframe元素），
       - `Window.frames[n]` (索引值，第n个iframe的window)。（获取内嵌iframe窗口的window）
         * 由于父页面window.frames === window（父页面自己），所以还可以使用window[n]
       - `Window.opener` （产生这个的窗口的页面的window，即使页面刷新也能获取到），
       - `Window.parent`（`<iframe>`内嵌窗口的的父页面的window）
         * *iframe的window.parent === 父页面的window，对于父页面window.parent就是它自己，子页面的window.parent就是它的父页面的window对象*
     * message
       * 要发送到其他窗口的数据。使用结构化克隆算法序列化数据。这意味着您可以将各种各样的数据对象安全地传递到目标窗口，而无需自己序列化。
     * targetOrigin
       * 指定要调度的事件的`targetWindow`的原点，可以是文字字符串`"*"`（表示无限制），也可以是URI。只有此参数中的协议、域名、端口 与targetWindow所在的页面的协议、域名、端口相同，目标窗口才可以接收到消息
   * 接收方页面的 message事件的事件对象event
     * event.origin：发送消息的页面所在的 源（字符串：协议、域名、端口号）
     * event.data：发送方传递的数据（会自动完成 字符串 > 对象）
     * event.source：发送方的window对象，打印会报错，但可以用来发送postMessage
   * 常见错误：
     * 调用postMessage的window对象搞错，一定是目标页面的 window对象
     * 试图打印其他页面window对象及其属性，会报错，但可以调用其方法

2. 使用过程

   1. **发送者页面中** 获取 **内嵌页面 / 被它打开的子页面** 的window对象

      ```js
      let demo2Window = document.getElementsByTagName('iframe')[0].contentWindow
      // 或者 window.frames[0]
      ```

   2. 使用目标页面的 window 调用 postMessage()方法，向目标页面发送数据

   3. 目标页面注册message事件，接收数据

      * 可以通过event.source 、 window.parent（iframe）等 获取发送方的window以发送响应

      ```js
      window.addEventListener('message', function (event) {
      	// 最好判断一下来源
      	if (event.origin !== "http://example.org") return
          event.source.postMessage('yes', 'http://localhost:3000/demo1.html')
          // window.parent.postMessage('yes', 'http://localhost:3000/demo1.html')
      })
      ```

3. 解决跨域
   * 代理思路：
     * 预先：在目标 源（跨域）中放置1个静态页面 proxy.html；然后在要发起跨域请求的页面source.html中内嵌1个隐藏的iframe（其src是指向proxy.html）
     * 页面要发起ajax请求，就把ajax请求的详情（参数）作为data，使用postMessage发送给proxy.html
     * proxy.html页面的onmessage方法中再对目标源发起ajax请求（此时就同源了）；proxy.html页面拿到响应，再把数据通过postMessage发送给source.html

#### 2.安全

##### 2.1 XSS跨站脚本攻击

###### 1）基本知识

1、XSS（Cross Site Scripting）跨站脚本攻击

（1）原理：页面渲染的数据中包含可运行的脚本

（2）攻击的基本类型：**反射型**（url参数直接注入）和**存储型**（存储到DB后读取时注入）

（3）注入点：HTML节点内的内容（text）；HTML中DOM元素的属性；Javascript代码；富文本

```html
//HTML节点内容注入
<div><script>alert(1);</script></div>  

//DOM属性注入
<img src='/images/1.png' onerror='alert(1);'>  

//javascript代码
<script>
    var a = '1';alert(1);''
</script>

//富文本是html标签，文字，以及样式的集合，很容易实现HTML节点内容注入和DOM属性注入，有被攻击的风险
```

###### 2）防范措施

* XSS攻击防御

  * 浏览器自带防御机制，主要应对反射型攻击（HTML内容或属性）：http响应头中自动添加x-xss-protection，值为0（关闭），1（打开），默认打开

  * 对特定字符做转义：内容注入替换尖括号（ < => \&lt;  > => \&gt; ） 属性注入替换单引号或双引号（ " => \&quot; ' => \&#39; ）

  * CSP（Content Security Policy）内容安全策略：用于指定哪些内容可执行

    * http响应头设置

    ```js
    //我们可以在http响应头中设置Content-Security-Policy
    //图片可以从任何地方加载(注意 "*" 通配符)
    //多媒体文件仅允许从 media1.com 和 media2.com 加载(不允许从这些站点的子域名)
    //可运行脚本仅允许来自于userscripts.example.com
    Content-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com
    ```

    * meta中也支持设置Content-Security-Policy

    ```js
    //同时meta中也支持设置Content-Security-Policy
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
    ```

##### 2.2 CSRF跨站请求伪造

###### 1）基本知识

原理：在第三方网站向本网站发起请求（如图）

<img src="F:\WebFrontendRep\webNote\image\安全\CSRF攻击原理.jpg" style="zoom: 50%;" />

1. 用户在A站前端页面发起登录（身份认证）请求，A站下发cookie（保存在浏览器中）
   * 用户再次访问A站时，浏览器会自动把cookie放在请求中，这样网站A就能识别出这个用户（是合法用户）

2. 用户又访问了B站，B站的前端页面 中包含对A站的请求（一般是get请求，post也可）

3. b站前端页面向a站后端发起请求（A站的接口），浏览器会自动带着a站的cookie信息（身份认证信息），请求成功

综上，可以清楚的知道，**只要用户访问了b站的前端页面，b站就可以在用户完全不知道的情况下，带着a站的用户登录态（cookie）向a站发起请求**

###### 2）防范措施

CSRF的发生有几个特点，**b站发送的请求带着a站的cookie信息； b站发送请求不经过a站的前端；http请求头中的referer为b站**。我们可以从这些特点入手，思考防御的办法：

1. 禁止第三方网站携带本网站的cookie信息
2. ==使用**验证码**或者添加**token验证**==
3. ==referer验证：禁止来自第三方的请求==

（1）禁止第三方网站携带本网站的cookie信息：设置same-site属性，same-site属性有两个值，Strict（**所有的第三方请求都不能携带**本网站的cookie）和Lax（链接可以，但是**form表单提交和ajax请求不行**）

（2）本网站前端页面添加验证信息：使用**验证码**或者添加**token验证**

　　验证码：当发起请求时，前端需要输入本网站页面的验证码信息，后端对验证码进行验证，验证码正确才会进行相关操作（存取数据等）

　　token验证：a站前端将token存在当前页面中（比如表单中的input隐藏域，meta标签或者任何一个dom的属性）和cookie中，当请求a站后端的时候，参数中带上这个token字段，a站后端将参数中的token和cookie中的token做对比， 相同则验证通过，不同则请求不合法

不管是验证码还是token验证，原理都是一样的，在a站前端页面加入验证，当第三方网站请求a站后端时，即使能携带a站cookie，但是因为没有经过a站的前端页面从而拿不到验证信息，也会导致请求失败。

两种防御的方法也有区别，验证码需要用户去填写，从而增加了用户使用网站的复杂度，而token验证在用户无感知的情况下就可以实现，不影响用户体验。我个人理解，验证码验证一般使用在需要提高用户认知的场景，比如，登录多次失败，修改个人信息（用户名，密码，绑定手机号等等），而一些获取商品列表信息，搜索等接口，使用token比较合理。可以看看我们平时使用的这些网站，作参考～

（3）referer验证：禁止来自第三方的请求

（4）使用post请求：有一个说法是“post请求比get请求更安全”，那这种说法对不对呢？实际上这种说法并不准确，对于CSRF攻击来讲，不管是post还是get都能实现攻击，区别只是**post请求攻击方需要构造一个form表单**才可以发起请求，比get请求（img的src， a标签的href等等）的攻击方式复杂了一些，但是并不能有效的阻止攻击。

##### 2.3 点击劫持(了解)

1、原理：第三方网站通过iframe内嵌某一个网站，并且将iframe设置为透明不可见，将其覆盖在其他经过伪装的DOM上，伪装的可点击DOM（按钮等）与实际内嵌网站的可点击DOM位置相同，当用户点击伪装的DOM时，实际上点击的是iframe中内嵌的网页的DOM从而触发请求操作

特点：用户自己做了点击操作；用户毫不知情；

2、点击劫持攻击防御

（1）Javascript禁止内嵌：当网页没有被使用iframe内嵌时，top和window是相等的；当网页被内嵌时，top和window是不相等的；可以在本网站的页面中添加如下判断：

```
<script>
if (top.location != window.location) {
    //如果不相等，说明使用了iframe，可进行相关的操作
}
</script>
```

但是这种方式并不是万能的，因为iframe标签中的属性sandbox属性是可以禁用内嵌网页的脚本的：

```
<iframe sandbox='allow-forms' src='...'></iframe>
```

（2）设置http响应头 X-Frame-Options：有三个值 **DENY（禁止内嵌）** **SAMEORIGIN（只允许同域名页面内嵌）** **ALLOW-FROM（指定可以内嵌的地址）**

　　 能在所有的web服务器端预设好X-Frame-Options字段值是最理想的状态。

（3）一些辅助手段，比如添加验证码，提高用户的防范意识

#### 3.算法

##### 3.1 排序

1. 冒泡排序——`bubbleSort(array, compareFn)`
   * 两两比较，大的往后放（后面的是排好的较大的）
2. 选择排序——`selectionSort(array, compareFn)`
   * 第一小的放第一位，第二小的放第二位（前面的是排好的较小的）
   * 假设本轮第一个元素是剩余元素中最小的，跟后续的逐一比较，找到最小元素的索引，放到本轮最前面
3. 插入排序——`insertionSort(array, compareFn)`
   * 假设第一项已经排序
   * 每一轮都把当前元素 逐一 与前面已排序元素比较，比自己大的统统向后移动1位，直至找到比自己小的（或到达最前面），把当前元素放在这个位置
4. 归并排序——`mergeSort(array, compareFn); merge(left, right, compareFn)`
   * 从中间划分数组，分别再对子数组进行归并排序，然后合并结果
   * 合并时分别从两个已排序的子数组中取值，总是取较小的放入结果中，直至其中一个取完，把另一个中剩余的拼接到结果后面
5. 快速排序——`quickSort(array, compareFn); quick(array, left, right, compareFn); partition(array, left, right, compareFn)`
   * 头是 left，尾是 right；左指针 i 从left开始，右指针 j 从right开始；
   * 头尾双指针向中间移动，左指针一直向右移动直至找到 大于等于 主元的元素停下；右指针一直向左移动直至找到 小于等于 主元的元素停下；如果左指针小于等于右指针，则交换它们指向的两个元素，并各自再移动一位；重复以上过程直至左指针大于右指针，将左指针返回
   * 此时左指针左侧的元素的最大值 必然小于 右侧元素的最小值，所以从左指针处将数组分成两份：`[left, i - 1]` 和 `[i, right]`，分别对子数组再进行快速排序

#### 4.性能

1. 提升页面性能的方法

   * 资源压缩合并，减少http请求（开启gzip、代码压缩）
   * 使用CDN
   * DNS预解析
   * 非核心代码异步加载
   * 利用浏览器缓存

2. 什么是DNS预解析

   * DNS 预解析：当浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在单击当前网页中的连接时就无需进行DNS的解析，减少用户等待时间，提高用户体验。 

   * 开启DNS预解析1：指定浏览器对特定域名进行预解析

     ```html
     <link  rel="dns-prefetch" href="//www.zhix.net">
     ```

   * `<meta  http-equiv="x-dns-prefetch-control" content="on">`

     * 浏览器会默认开启 a 标签的DNS预解析
     * 但是对于https协议，很多浏览器会默认关闭a标签的DNS预解析，这一行就是打开a链接的DNS预解析

3. 异步加载

   * 页面解析 和 资源加载是可以同时进行的；
   * 但 页面解析（其实也是js执行） 和 js执行不能同时进行

   1. 异步加载方式：
      * 动态脚本加载
        * 就是当需要某个功能时，动态地向页面中插入1个script标签，来请求响应功能的js代码并执行
      * defer：script标签的一个属性`<script defer></script>`
        * 添加了defer的script会在HTML解析完毕再执行，且会保证执行顺序
      * async：script标签的一个属性`<script async></script>`（仅适用于外部脚本，即通过src加载的脚本）
        * js脚本加载完毕就会立即执行（页面解析会暂停），不会保证执行顺序，即谁先加载完谁先执行

4. 浏览器缓存

   * 缓存的分类：强缓存 和 协商缓存
   * 强缓存：都是服务器把以下字段填入http响应头中，告诉浏览器进行资源缓存
     * Expires：字段的值是一个绝对时间，即缓存有效期的截止时间
     * Cache-Control：字段的值是一个相对时间（秒数），即多少秒后缓存失效
       * 常见的设置是max-age public private no-cache no-store等
   * 协商缓存：就是浏览器请求资源时发现它的缓存（可能根本就没有缓存）过期了，通过协商缓存来确定是否需要更新这个资源
     * 协商缓存要用到 两种信息：资源的hash值（etag、if-none-matched），资源的修改时间（last-modified、if-modified-since）
       * etag、if-none-matched都是资源的hash值，前者是服务器响应头中的字段名，后者是浏览器请求头中的字段名。last-modified、if-modified-since同理
     * 过程：
       * 服务器在响应头中设置 **资源的hash值，资源的修改时间**，告诉浏览器此资源使用协商缓存，此资源会被缓存
       * 当再次请求此资源时，浏览器会把 **资源的hash值，资源的修改时间** 放入请求头中，发送给服务器
       * 服务器根据这两个信息判断此资源是否已过期（更新）
         * 没有过期：服务器响应  304，告诉浏览器使用老的资源
         * 过期：服务器响应200，返回新的资源

5. 性能优化补充

   （1）提升HTML的加载速度

   - 页面精简，删除不必要的内容，将内嵌的JS和CSS移至外部文件，使用压缩工具等

   - 减少文件数量，合并文件，减少请求次数

   - 减少域名查询，外部引入的资源尽量少使用不同的域名

   - 使用缓存，重用数据

   - 优化页面元素的加载顺序

   - 使用合法的标签

   - 根据浏览器类型选择合适的策略

   （2）编写合理的CSS

   - DOM的深度尽量浅

   - 使用合法的CSS属性

   - 不要为ID选择器指定类名或标签名

   - 避免使用后代选择器，尽量使用子选择器

   - 避免使用通配符

   （3）关于JS标签

   js标签的加载和执行特点：载入后立即执行，执行时会阻塞页面后续内容

   - 将所有的js标签放在页面底部，保证脚本执行前已完成DOM渲染

   - 尽可能合并脚本

   - 减少内联js的使用

   - 注意多个js标签的引入顺序

   - 使用defer属性，该属性可以使脚本在文档完全呈现以后再执行

   - 使用async属性，可以使当前脚本不必等待其他脚本的执行，也不必阻塞文档的呈现

#### 5.错误处理

1. 前端错误分类

   * 即时运行错误：代码错误
   * 资源加载错误

2. 如何捕获前端错误（如何保证产品的质量）

   * 代码错误：
     * try...catch；
     * window.onerror事件
   * 资源加载错误：
     * object.onerror（object是页面元素，如img）
     * *performance.getEntries()：返回一个数组，包含所有成功加载的资源的PerformanceEntry对象*
       * 可以通过参数对资源进行过滤，详见MDN
       * 然后拿到所有的某一类DOM对象（例如img），看看这些对象有没有在上述数组中，就可以找出哪些图片加载失败
     * Error事件捕获（资源加载错误不会冒泡，但可以设置window.addEventListener('error', fn, true)设置为事件捕获）

3. 跨域的js错误

   * 跨域的js错误可以捕获，但是不能直接获取到错误详情（只有一个Script error）
   * 要获取错误详情，可以（以下两步要同时满足）：
     * 1.在script标签中加上crossorigin属性
     * 2.设置js资源响应头 访问控制 字段（Access-Control-Allow-Origin：*）

4. 错误上报方式

   * 通过Ajax（*可以但不好*）

   * 利用Image对象上报：new Image()会创建1个新的img元素，改变它的src属性时，它就会发出1个get请求，把错误信息作为search参数传递即可

     ```js
     new Image().src = '/abc?key=abc&value=123'
     ```

   