# 算法——JavaScript

## 一、基本概念

### 1. 算法分析中常用的函数

1. `m = kn + b`：线性函数，线性关系
2. `m = a^n`：指数函数，指数关系（a为常量）
3. `m = loga(n)`：对数函数，对数关系
4. `m = n^a`：幂函数，当a为2时，平方关系

### 2. 大O符号

* 时间复杂度：即一个算法（js函数）的运行时间与输入值（自变量）的关系。一般并不关系精确的数值关系，更关心二者的变化曲线
* 算法中使用 O()来表示时间复杂度，括号中是代表时间复杂度的函数关系
* 常见的时间复杂度：
  * 常数时间复杂度：O(1)
  * 对数时间复杂度：O(log n)
  * 线性时间复杂度：O(n)
  * 线性对数时间复杂度：O(nlog n)
  * 平方时间复杂度：O(n^2)
  * 指数时间复杂度：O(2^n)

### 3. 推导时间复杂度

1. 定义函数：其实就是分析算法（的代码）的执行==行数== 与输入值的关系
   * 假定每行代码的执行时间一样（因为不需要分析精确的执行时间），以行数代表执行时间
2. 找到最快增长项，留下，其他项都去掉
3. 去掉系数

* 例如
  1. 某算法的 执行行数，与输入值的关系为 T = 3n + 3
  2. 最快增长项为 3n
  3. 去掉系数 得 n
  4. 所以它的时间复杂度为 O(n)，线性时间复杂度

## *、常见算法问题

### 1. 背包问题

* 问题描述：有一系列物品，每一件物品都有各自的 `价值（value）` 和 `重量（weight）`，怎样选取物品，才能让重量不超过 W（已知数），且总价值最大

### 2. 累加问题

* 问题描述：给定一个正整数 n，计算 1 + 2 + 3 + ... + n-1 + n 的结果

#### 2.1 循环累加

* 即从 1 开始循环，已知累加到 n

* 时间复杂度：O(n)

  ```javascript
  function getSum(n) {
  	let sum = 0
      for (let i = 1; i <= n; i++) {
          sum += i
      }
      return sum
  }
  ```

#### 2.2 利用等差数列求和公式

* 公式：公式中首项为a1，末项为an，项数为n，公差为d，前n项和为Sn。

$$
S_n= na_1 + \frac{n(n-1)}{2}d , n∈N^*
$$

或者
$$
S_n=\frac{n(a_1+a_n)}{2} , n∈N^*
$$

* 利用公式2，可得累加问题的 算法为 n*(n+1) / 2

* 时间复杂度：O(1)

  ```javascript
  function getSum(n) {
  	return n * (n + 1) / 2
  }
  ```

#### 2.3 优化算法的思路1

* 看看需要使用循环的问题，是否有现成的数学公式

### 3. 斐波那契数列

* 问题描述：计算斐波那契数列（1， 1， 2， 3， 5， ...）的第n项 的值
  * 兔子繁殖问题：已知兔子长到两个月大的时候，就会开始繁殖，假设每对兔子每月只繁殖1对小兔子。问，1月份买来一对小兔子，到12月（年底）能有多少对兔子（假设兔子的性别是1:1）
  * 兔子问题其实就是斐波那契数列求第n项问题
  * 每个月的兔子
    * 上上个月的兔子（全是老兔子，即本月的老兔子）
    * 上个月的新兔子（本月是幼年兔子）
    * 上个月的老兔子 + 上个月的幼年兔子（本月老兔子 = 本月的老兔子生的新兔子）
  * 每个月的兔子 = 上上个月的兔子 + 上个月的兔子

| 时间     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 老兔子   | 0    | 0    | 1    | 1    | 2    | 3    | 5    | 8    | 13   | 21   | 34   | 55   |
| 幼年兔子 | 0    | 1    | 0    | 1    | 1    | 2    | 3    | 5    | 8    | 13   | 21   | 34   |
| 新兔子   | 1    | 0    | 1    | 1    | 2    | 3    | 5    | 8    | 13   | 21   | 34   | 55   |
| 总共     | 1    | 1    | 2    | 3    | 5    | 8    | 13   | 21   | 34   | 55   | 89   | 144  |

#### 3.1 逐项求值

* 对于斐波那契数列，最简单的办法就是 从头开始算
* 线性时间复杂度：O(n)

1. 保存每一项（较消耗内存）：逻辑简单

   ```javascript
   function fib(n) {
   	if (n === 1) {
   		return 1
   	}
   	if (n === 2) {
   		return 1
   	}
   	let arr = [1, 1]
   	for (let i = 2; i < n; i++) {
   		arr.push(arr[i - 1] + arr[i - 2])
   	}
   	return arr[arr.length - 1]
   }
   ```

2. 不保存每一项：数组中永远只有两项

   ```javascript
   function fib(n) {
   	if (n === 1) {
   		return 1
   	}
   	if (n === 2) {
   		return 1
   	}
   	let arr = [1, 1]
   	for (let i = 2; i < n; i++) {
   		arr.push(arr[0] + arr[1])
   		arr.shift()
   	}
   	return arr[1]
   }
   ```

#### 3.2 递归

* 每一次函数调用，只要返回上一个数 和上上个数的和即可

  * 缺点，内存占用呈指数增长，n的值较大时，性能急剧下降

  ```javascript
  function fib(n) {
  	if (n === 1) {
  		return 1
  	}
  	if (n === 2) {
  		return 1
  	}
  	return fib(n - 1) + fib(n - 2)
  }
  ```


### 4. 判断质数

* 只要一个正整数存在 除了1和它自身之外的其他因数，这个数就不是质数，否则，它就是质数

#### 4.1 逐个取余

* 只要对 大于1小于n的 n-2个数逐个进行 取余，只要全部都不能整除，n就是质数

* 线性时间复杂度：O(n)

  * 最好情况：n是2的倍数
  * 最差情况：n是一个较大的质数 => O(n)

  ```javascript
  function isPrime(n) {
  	for (let i = 2; i < n; i++) {
  		if (n % i === 0) {
  			return false
  		}
  	}
  	return true
  }
  ```

#### 4.2 只判断到 n的平方根

* 由于 一个正整数n的 两个因数中，有且只有1个小于它的平方根。特别地，当n的平方根为正整数时，两个因数可以都等于它的平方根

* 平方根时间复杂度：O(sqrt n)

  * 最好情况：n是2的倍数
  * 最差情况：n是一个较大的质数 => O(sqrt n)

  ```javascript
  function isPrime(n) {
  	let sqrtOfn = Math.floor(Math.sqrt(n))
  	for (let i = 2; i <= sqrtOfn; i++) {
  		if (n % i === 0) {
  			return false
  		}
  	}
  	return true
  }
  ```

#### 4.3 优化算法的思路2

* 看看能不能 改变 for循环的结束条件，使循环次数减少

### 5. 判断2的整数次幂

* 给一个正整数 n，判断它是否是2的整数次幂，即 $2^a?=n$ ，a为正整数

#### 5.1 结合短除法判断

* 若n是2的整数次幂，则对n进行短除法，每一次的余数都是0，直至商（取整）为1，只要在商为1之前出现了余数不是1的情况，它就不是2的整数次幂

* 对数时间复杂度：O(log n)

  * 最好情况：n是一个奇数，循环只执行一次就返回了 => O(1)
  * 最坏情况：n是一个较大的 2的整数次幂，需要执行 log n次 => O(log n)

  ```javascript
  function isPowerOfTwo(n) {
  	if (n < 1) {
  		return false
  	}
  	if (n === 1) {
  		return true
  	}
  	let shang = n
  	while(shang != 1) {
  		// 判断本次除法的余数，若不为0，则直接return false
  		if (shang % 2 != 0) {
  			return false
  		}
  		// 求商
  		shang = Math.floor(shang / 2)
  	}
  	return true
  }
  ```

#### 5.2 按位运算判断法

1. js的按位运算：虽然很少用，但js是支持按位运算的
   * 按位与：&，操作数可以直接使用十进制数，js会把两个操作数的二进制进行 按位与运算，再返回结果的十进制形式

2. 规律：设 正整数 a 为 2的整数次幂的结果，即2^n=a，则 a & (a -1) = 0。

   * 即：一个正整数 与 它减一的数 按位与，结果一定是0
   * 原因：2的整数次幂的数，写成2进制，都是形如1000这样的，它减去1，必然得到位数少1且全为1的二进制数（0111），二者按位与，必然为0
     其他（不是2的整数次幂的数）写成二进制，除了最高位以外，必然还有其他位存在1，就导致减1时，借位无法传递到最高位，所以它减去1得到的数的二进制最高位必然还是1，且不会少位，于是按位与之后不可能是0

3. 常数时间复杂度：O(1)

   ```javascript
   function isPowerOfTwo(n) {
   	return ((n & (n - 1)) === 0)
   }
   ```

   

